[
  {
    "question": "What is one of the learning objectives regarding OpenACC directives?",
    "answer": "One learning objective is to understand what an OpenACC directive is."
  },
  {
    "question": "What is the learning objective related to the `loop` and `kernels` directives?",
    "answer": "A learning objective is to understand the difference between the `loop` and `kernels` directives."
  },
  {
    "question": "What process is a key learning objective to understand when porting code?",
    "answer": "Understanding the process of 'offloading' is a key learning objective."
  },
  {
    "question": "What is a fundamental difference between a CPU and a GPU regarding memory access?",
    "answer": "The CPU (host) and GPU do not share the same memory."
  },
  {
    "question": "Describe the general characteristics of host memory compared to GPU memory.",
    "answer": "Host memory is generally larger, but slower than GPU memory."
  },
  {
    "question": "Can a GPU directly access the host memory?",
    "answer": "No, a GPU does not have direct access to the host memory."
  },
  {
    "question": "How is data transferred from the main program to the GPU for processing?",
    "answer": "Data must be transferred from the main program to the GPU through the PCI bus."
  },
  {
    "question": "What is the bandwidth of the PCI bus in relation to host and GPU memories?",
    "answer": "The PCI bus has a much lower bandwidth than either host or GPU memories."
  },
  {
    "question": "What is the term for transferring data and code onto a device like a GPU?",
    "answer": "Transferring the data and the code onto the device is called 'offloading'."
  },
  {
    "question": "What form do OpenACC directives take in C/C++?",
    "answer": "In C/C++, OpenACC directives take the form of `pragma` statements."
  },
  {
    "question": "How are OpenACC directives expressed in Fortran?",
    "answer": "In Fortran, OpenACC directives are expressed as comments."
  },
  {
    "question": "What is an advantage of using OpenACC directives for debugging purposes?",
    "answer": "Since OpenACC involves very minor code modifications, changes can be done incrementally, which is useful for debugging to quickly identify which change created a bug."
  },
  {
    "question": "How can OpenACC support be controlled during compilation?",
    "answer": "OpenACC support can be disabled at compile time, treating the `pragma` statements as comments, allowing a single source code for both accelerated and normal versions."
  },
  {
    "question": "What benefit does OpenACC offer regarding supporting various accelerator types?",
    "answer": "The same code can be compiled for various accelerator types like GPUs or SIMD instructions on CPUs, and only the compiler needs updating for new device generations."
  },
  {
    "question": "How many kernels does the compiler typically identify in the C/C++ example shown with `#pragma acc kernels` enclosing two loops?",
    "answer": "The compiler will typically identify two kernels, corresponding to the inside of each loop."
  },
  {
    "question": "How are OpenACC blocks delimited in C/C++ code?",
    "answer": "In C/C++, the OpenACC block is delimited using curly brackets."
  },
  {
    "question": "How are OpenACC blocks delimited in Fortran code?",
    "answer": "In Fortran, the same comment needs to be repeated, with the `end` keyword added."
  },
  {
    "question": "What happens when the compiler reaches an OpenACC `kernels` directive?",
    "answer": "The compiler will analyze the code to identify sections that can be parallelized, often the body of a loop with independent iterations."
  },
  {
    "question": "What is a 'kernel' in the context of OpenACC's `kernels` directive?",
    "answer": "A 'kernel' is a special function that the compiler wraps the body of a parallelizable loop into, ensuring each call is independent for execution on an accelerator."
  },
  {
    "question": "How do kernels run on an accelerator?",
    "answer": "Since each call is independent, each of the hundreds of cores of the accelerator can run the function for one specific index in parallel."
  },
  {
    "question": "What type of directive is the `kernels` directive considered?",
    "answer": "The `kernels` directive is considered a 'descriptive' directive."
  },
  {
    "question": "What does a 'descriptive' directive like `kernels` imply about the compiler's behavior?",
    "answer": "It tells the compiler that the programmer 'thinks' the region can be parallel, but the compiler is free to choose the best strategy, including running it sequentially."
  },
  {
    "question": "What are the typical actions a compiler takes when it encounters a `kernels` directive?",
    "answer": "It will typically analyze the code for parallelism, identify data to be transferred, create a kernel, and offload the kernel to the GPU."
  },
  {
    "question": "What is the main difference between OpenMP and OpenACC directives regarding their nature?",
    "answer": "OpenMP directives are generally 'prescriptive' in nature, while many of OpenACC's directives are 'descriptive'."
  },
  {
    "question": "What does it mean for an OpenMP directive to be 'prescriptive'?",
    "answer": "It means the compiler is required to perform the requested parallelization, leading to reproducible results and consistent parallelization across hardware."
  },
  {
    "question": "What does it mean for an OpenACC directive to be 'descriptive'?",
    "answer": "It means the compiler is free to compile the code in the way it thinks is best for the target architecture, which may even mean not parallelizing at all."
  },
  {
    "question": "Can the same OpenACC code yield different binary code when compiled for a GPU versus a CPU?",
    "answer": "Yes, because OpenACC's descriptive nature allows the compiler to optimize the code differently for each target architecture."
  },
  {
    "question": "What is a learning objective related to C/C++ aliasing?",
    "answer": "A learning objective is to understand what 'aliasing' is in C/C++."
  }
]