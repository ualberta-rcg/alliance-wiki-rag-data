[
  {
    "question": "What is an alternative to changing the Julia depot path to avoid quota issues?",
    "answer": "An alternative is to create an Apptainer image with a chosen version of Julia and a selection of packages, and redirect JULIA_DEPOT_PATH inside the container."
  },
  {
    "question": "What are the advantages of using an Apptainer image for Julia packages?",
    "answer": "Using an Apptainer image can contain a potentially very large set of small files inside one container file (.sif), which may improve IO performance. It also improves reproducibility, allows the container to run anywhere as-is, enables testing Julia nightly builds without altering local installations, and provides complete control for bundling specific dependencies."
  },
  {
    "question": "What is a disadvantage of using Apptainer images for Julia packages?",
    "answer": "A disadvantage is that you lose the advantage of optimized Julia modules provided by the clusters."
  },
  {
    "question": "How do you interface Python code with Julia using PyCall.jl?",
    "answer": "To interface Python code with Julia using PyCall.jl, you need to set the `PYTHON` environment variable to the Python executable in your virtual Python environment."
  },
  {
    "question": "What are the recommended steps to configure PyCall.jl on Alliance clusters?",
    "answer": "You should activate a virtual Python environment (`source \"$HOME/myenv/bin/activate\"`), then in Julia, set `ENV[\"PYTHON\"] = joinpath(ENV[\"VIRTUAL_ENV\"], \"bin\", \"python\")`, and finally run `Pkg.build(\"PyCall\")`."
  },
  {
    "question": "Why is the default PyCall.jl behavior of using a Miniconda distribution not recommended on Alliance clusters?",
    "answer": "The default PyCall.jl behavior using a Miniconda distribution is not recommended because Anaconda and similar distributions are not suitable on the clusters, and the Miniconda installer creates a large number of files inside JULIA_DEPOT_PATH, which can lead to performance and quota issues if it's the default `~/.julia`."
  },
  {
    "question": "How can you run Julia with multiple processes on a cluster using a machine file?",
    "answer": "You can run Julia with multiple processes by first generating a list of allocated node names with `srun hostname -s > hostfile`, and then executing your Julia program using `julia --machine-file ./hostfile ./pi_p.jl <arguments>`."
  },
  {
    "question": "What is the purpose of the `srun hostname -s > hostfile` command in a parallel Julia script?",
    "answer": "The command `srun hostname -s > hostfile` generates a list of the short hostnames of the nodes allocated to the job and writes this list to a text file named `hostfile`."
  },
  {
    "question": "How should Julia's MPI be configured for versions 0.19 or earlier on Alliance clusters?",
    "answer": "For Julia MPI 0.19 or earlier, you must `module load StdEnv julia`, then export `JULIA_MPI_BINARY=system`, `JULIA_MPI_PATH=$EBROOTOPENMPI`, `JULIA_MPI_LIBRARY=$EBROOTOPENMPI/lib64/libmpi.so`, `JULIA_MPI_ABI=OpenMPI`, and `JULIA_MPIEXEC=$EBROOTOPENMPI/bin/mpiexec` before running `Pkg.add(\"MPI\")` in Julia."
  },
  {
    "question": "What are the configuration steps for Julia's MPI for versions 0.20 or later?",
    "answer": "For Julia MPI 0.20 or later, first `module load julia`, then create a directory `.julia/environments/v${EBVERSIONJULIA%.*}` and append an `[MPIPreferences]` section with specific settings (abi, binary, libmpi, mpiexec) to your `LocalPreferences.toml` file, ensuring any existing `[MPIPreferences]` section is removed. Afterward, in Julia, run `import Pkg; Pkg.add(\"MPIPreferences\"); Pkg.add(\"MPI\")`."
  },
  {
    "question": "How do you execute a Julia MPI program after it has been configured?",
    "answer": "After configuration, load `StdEnv` and `julia` modules, then execute the program using `mpirun -np <number_of_processes> julia <your_program.jl>`, for example, `mpirun -np 2 julia hello.jl`."
  },
  {
    "question": "How can you restrict the number of threads Julia uses?",
    "answer": "You can restrict the number of threads Julia uses by setting the environment variable `JULIA_NUM_THREADS=k`, where `k` is the desired number of threads."
  },
  {
    "question": "What is the purpose of the `JULIA_EXCLUSIVE` environment variable in Julia threading?",
    "answer": "Setting `JULIA_EXCLUSIVE` to anything non-zero takes control of thread scheduling away from the OS and pins threads to cores, which can improve performance if there's precise information on cache access patterns or unwelcome OS scheduling patterns."
  },
  {
    "question": "Under what condition does `JULIA_EXCLUSIVE` work effectively?",
    "answer": "`JULIA_EXCLUSIVE` works only if your job has exclusive access to the compute nodes (all available CPU cores were allocated to your job)."
  },
  {
    "question": "What does `JULIA_THREAD_SLEEP_THRESHOLD` control?",
    "answer": "`JULIA_THREAD_SLEEP_THRESHOLD` controls the number of nanoseconds after which a spinning thread is scheduled to sleep, where a value of 'infinite' (as a string) indicates no sleeping on spinning."
  },
  {
    "question": "When might setting `JULIA_THREAD_SLEEP_THRESHOLD` to 'infinite' be beneficial?",
    "answer": "Setting `JULIA_THREAD_SLEEP_THRESHOLD` to 'infinite' can result in lower latency in situations where a resource is only very infrequently contended, by prohibiting threads from sleeping."
  },
  {
    "question": "What is the primary programming interface for GPUs in Julia and how is it installed?",
    "answer": "Julia's primary programming interface for GPUs is the CUDA.jl package. It can be installed by loading `cuda/11.4 julia/1.8.1` modules, then in Julia, running `import Pkg; Pkg.add(\"CUDA\")`."
  },
  {
    "question": "How do you configure CUDA.jl to use a local CUDA toolkit if the downloaded one is incompatible?",
    "answer": "If the downloaded CUDA toolkit is incompatible, you can configure Julia to use the local CUDA toolkit by running `using CUDA; CUDA.set_runtime_version!(v\"version_of_cuda\", local_toolkit=true)` (e.g., `v\"12.2\"`), or `CUDA.set_runtime_version!(\"local\")` for older CUDA versions."
  },
  {
    "question": "How can you verify that Julia is using the correct CUDA version?",
    "answer": "After restarting Julia, you can verify the CUDA version by running the command `CUDA.versioninfo()`."
  },
  {
    "question": "Where can one find online seminars about Julia?",
    "answer": "A series of online seminars produced by SHARCNET are available, including 'Julia: A first perspective', 'Julia: A second perspective', and 'Julia: A third perspective - parallel computing explained'."
  }
]