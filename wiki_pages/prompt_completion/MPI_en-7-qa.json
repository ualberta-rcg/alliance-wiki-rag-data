[
  {
    "question": "How can one implement a safe MPI program when using `MPI_Send` and `MPI_Recv` to avoid deadlocks?",
    "answer": "A common solution is to adopt an odd-even pairing approach, where all even-ranked processes execute a send followed by a receive, while all odd-ranked processes execute a receive followed by a send."
  },
  {
    "question": "Does the odd-even pairing strategy for safe MPI communication lead to deadlocks if the number of processors is odd?",
    "answer": "No, there is no chance of a deadlock. Process 0's send is correctly paired with process 1's receive, guaranteeing completion. Process 0 will then proceed to receive the message from process N-1, even if there's a small delay."
  },
  {
    "question": "What is the recommended approach for implementing frequently occurring communication patterns in MPI?",
    "answer": "It is recommended to use the collective communication functions of MPI for frequently occurring communication patterns, instead of implementing them manually with `MPI_Send` and `MPI_Recv`."
  },
  {
    "question": "What are MPI compiler wrappers?",
    "answer": "MPI compiler wrappers are not compilers themselves but scripts provided by MPI library packages that call other compilers and pass MPI-specific flags to them."
  },
  {
    "question": "What are the typical names for MPI compiler wrappers for C, C++, and Fortran?",
    "answer": "Typically, `mpicc` is used for C, `mpicxx` for C++, and `mpifort`, `mpif77`, or `mpif90` for Fortran."
  },
  {
    "question": "What is the purpose of the `--showme` option when used with Open MPI compiler wrappers?",
    "answer": "The `--showme` option prints which compiler will be called and which compiler-options will be added."
  },
  {
    "question": "How do MPI compiler wrappers, such as those in Open MPI, determine which underlying compiler and version to use?",
    "answer": "The MPI compiler-wrappers will always use the compiler and compiler version that has been loaded with the `module load` command."
  }
]