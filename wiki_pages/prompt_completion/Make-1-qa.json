[
  {
    "question": "What is `make`?",
    "answer": "`make` is a utility that automatically builds files, such as executables or libraries, from other files, such as source code."
  },
  {
    "question": "How does the `make` command operate?",
    "answer": "The `make` command interprets and executes instructions found within a file named `makefile`."
  },
  {
    "question": "What is the primary advantage of using `make` compared to a simple script?",
    "answer": "Unlike a simple script, `make` only executes the commands that are necessary, avoiding the need to redo all steps to arrive at a result."
  },
  {
    "question": "What kind of information does a `makefile` contain?",
    "answer": "A `makefile` contains information on 'dependencies'."
  },
  {
    "question": "Can you give an example of how `make` handles dependencies?",
    "answer": "If a `makefile` indicates that an object (`.o`) file depends on a source file, and the source file has changed, then `make` recompiles the source file to update the object file. Similarly, if an executable depends on changed object files, the linking step is rerun."
  },
  {
    "question": "What is the benefit of including all dependencies in a `makefile`?",
    "answer": "It is not necessary to recompile all files for every modification; the `make` command takes care of recompiling and relinking only what is necessary."
  },
  {
    "question": "What is the main argument used with the `make` command?",
    "answer": "The main argument of the `make` command is the 'target'."
  },
  {
    "question": "What can a `make` target represent?",
    "answer": "A target may be the name of some file that `make` should build, or it may be an abstract target such as `all`, `test`, `check`, `clean`, or `install`."
  },
  {
    "question": "What is the typical behavior if `make` is invoked with no target specified?",
    "answer": "If `make` is invoked with no target specified, the typical behavior is to construct everything, which is equivalent to `make all`."
  },
  {
    "question": "How are the `test` or `check` targets generally used?",
    "answer": "The `test` or `check` targets are generally used to run tests to validate if the application or compiled library functions correctly."
  },
  {
    "question": "How can one verify compilation using `make` with `test` or `check` targets?",
    "answer": "You can verify the compilation using `make all && make check` or `make all && make test`."
  },
  {
    "question": "What is the function of the `clean` target?",
    "answer": "The `clean` target erases all previously compiled binary files to be able to recompile from scratch."
  },
  {
    "question": "What is the difference between the `clean` and `distclean` targets?",
    "answer": "The `clean` target erases all previously compiled binary files, while the `distclean` target not only deletes files made by `make` but also files created at configuration time by `configure` or `cmake`."
  },
  {
    "question": "How do you clean the compilation directory using `make`?",
    "answer": "To clean the compilation directory, you can usually run `make clean` and sometimes `make distclean`."
  },
  {
    "question": "What does the `install` target typically do?",
    "answer": "The `install` target normally installs a compiled program or library."
  },
  {
    "question": "How can the installation location for the `install` target be modified?",
    "answer": "The installation location can often be modified using an additional `prefix` parameter, for example: `make install prefix=$HOME/PROGRAM`."
  },
  {
    "question": "Are target names like `all`, `test`, `check`, `clean`, `distclean`, and `install` mandatory?",
    "answer": "No, these targets are only conventions, and a `makefile` author could choose another convention."
  },
  {
    "question": "What is the goal and functioning of the example `Makefile` provided?",
    "answer": "The goal is to easily update the compilation of a program (`.out`) containing multiple separated routines. The `make` command reads and interprets it, verifying the dates of components and recompiling only modified routines (in `.o` form), then linking them to form an updated version of the final program."
  },
  {
    "question": "According to the example `Makefile`, how do you update the whole program using `make`?",
    "answer": "Type `make` to update the whole program."
  },
  {
    "question": "According to the example `Makefile`, how do you update only a specific routine using `make`?",
    "answer": "Type `make RoutineName` to only update the RoutineName routine."
  }
]