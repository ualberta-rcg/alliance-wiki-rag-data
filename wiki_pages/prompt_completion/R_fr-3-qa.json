[
  {
    "question": "Comment passer des arguments \u00e0 un script R ?",
    "answer": "Les arguments peuvent \u00eatre pass\u00e9s au script R avec la commande `Rscript myscript.R input_1.csv 5`."
  },
  {
    "question": "Comment un script R acc\u00e8de-t-il aux arguments qui lui ont \u00e9t\u00e9 pass\u00e9s ?",
    "answer": "Le script R peut acc\u00e9der aux arguments en utilisant `args = commandArgs(trailingOnly=TRUE)`."
  },
  {
    "question": "Comment v\u00e9rifier le nombre d'arguments fournis \u00e0 un script R ?",
    "answer": "Dans le script R, vous pouvez v\u00e9rifier le nombre d'arguments avec `if (length(args)<2) { stop(\"At least two arguments must be supplied...\") }`."
  },
  {
    "question": "Comment convertir un argument de script R en un nombre entier ?",
    "answer": "Un argument peut \u00eatre converti en entier en utilisant `as.integer( args[index] )`."
  },
  {
    "question": "Pourquoi la programmation parall\u00e8le est-elle importante pour R sur les supercalculateurs ?",
    "answer": "La programmation parall\u00e8le permet de profiter des milliers de CPU sur un r\u00e9seau tr\u00e8s performant offerts par les supercalculateurs, m\u00eame si les processeurs sont ordinaires."
  },
  {
    "question": "Quelle est la premi\u00e8re \u00e9tape \u00e0 faire avant de parall\u00e9liser du code R ?",
    "answer": "Avant de parall\u00e9liser le code R, il est essentiel de s'assurer que l'impl\u00e9mentation s\u00e9quentielle est aussi efficiente que possible."
  },
  {
    "question": "Quels sont les goulots d'\u00e9tranglement de performance courants en R, surtout dans le code s\u00e9quentiel ?",
    "answer": "D'importants goulots d'\u00e9tranglement sont caus\u00e9s par les boucles, et particuli\u00e8rement les boucles imbriqu\u00e9es, ce qui a un impact sur la performance en R."
  },
  {
    "question": "Quelles techniques peuvent am\u00e9liorer la performance en R sans n\u00e9cessiter de parall\u00e9lisation ?",
    "answer": "L'utilisation de fonctions vectorielles et d'\u00e9l\u00e9ments plus fonctionnels comme la famille des fonctions `apply` et la fonction `ifelse` peut souvent offrir un gain de performance en \u00e9liminant les boucles."
  },
  {
    "question": "O\u00f9 trouver des informations sur les paquets R pour le calcul de haute performance et parall\u00e8le ?",
    "answer": "La page 'CRAN Task View on High-Performance and Parallel Computing with R' contient une liste de paquets."
  },
  {
    "question": "Que signifie le terme 'n\u0153ud' dans la documentation des supercalculateurs ?",
    "answer": "Dans la documentation, 'n\u0153ud' peut d\u00e9signer un ordinateur distinct ou un processus de travail (worker process)."
  },
  {
    "question": "Que signifie le terme 'grappe' (cluster) dans le contexte des supercalculateurs ?",
    "answer": "Une 'grappe' est un regroupement de 'n\u0153uds' ou d''h\u00f4tes', ou un regroupement de processus de travail (worker processes)."
  },
  {
    "question": "Quel est le r\u00f4le du paquet `foreach` dans R pour la parall\u00e9lisation ?",
    "answer": "`foreach` sert d'interface unifi\u00e9e pour divers syst\u00e8mes dorsaux (backends) comme doMC, doMPI, doParallel, doRedis, permettant une ex\u00e9cution parall\u00e8le sur diff\u00e9rentes plateformes."
  },
  {
    "question": "Comment `doParallel` s'int\u00e8gre-t-il avec `foreach` ?",
    "answer": "`doParallel` agit comme une interface entre `foreach` et le paquet `parallel` de R et peut \u00eatre charg\u00e9 seul."
  },
  {
    "question": "Quels sont les probl\u00e8mes de performance connus avec `foreach` ?",
    "answer": "Des probl\u00e8mes de performance connus surviennent avec `foreach` lors de l'ex\u00e9cution d'un tr\u00e8s grand nombre de tr\u00e8s petites t\u00e2ches."
  },
  {
    "question": "Quelles sont les \u00e9tapes g\u00e9n\u00e9rales pour utiliser `foreach` pour la programmation parall\u00e8le ?",
    "answer": "Les \u00e9tapes g\u00e9n\u00e9rales sont : charger `foreach` et le paquet dorsal, enregistrer le paquet dorsal, et appeler `foreach()` sur la m\u00eame ligne que l'op\u00e9rateur `%dopar%`."
  },
  {
    "question": "Que se passe-t-il si le syst\u00e8me dorsal n'est pas enregistr\u00e9 avant d'utiliser `foreach` ?",
    "answer": "Si le syst\u00e8me dorsal n'est pas enregistr\u00e9, `foreach` assume que le nombre de c\u0153urs est 1 et ex\u00e9cute les it\u00e9rations de fa\u00e7on s\u00e9quentielle."
  },
  {
    "question": "Comment enregistrer le nombre de c\u0153urs pour `doParallel` dans un script R ?",
    "answer": "Le nombre de c\u0153urs est enregistr\u00e9 avec `registerDoParallel(cores=ncores)`."
  },
  {
    "question": "Comment un script R peut-il obtenir le nombre de c\u0153urs allou\u00e9s par SLURM ?",
    "answer": "Le nombre de c\u0153urs allou\u00e9s par SLURM peut \u00eatre obtenu en lisant la variable d'environnement `SLURM_CPUS_PER_TASK` via `Sys.getenv(\"SLURM_CPUS_PER_TASK\")`."
  },
  {
    "question": "Quelle est la syntaxe pour des boucles `foreach` imbriqu\u00e9es et parall\u00e9lis\u00e9es en R ?",
    "answer": "La syntaxe est `foreach(var1=var1.v, .combine=rbind) %:% foreach(var2=var2.v, .combine=rbind) %dopar% {test_func(var1=var1, var2=var2)}`, en veillant \u00e0 ce que `foreach()` et `%dopar%` soient sur la m\u00eame ligne."
  },
  {
    "question": "Comment soumettre un script R utilisant `doParallel` et `foreach` \u00e0 SLURM ?",
    "answer": "Un script bash (`job_foreach.sh`) doit \u00eatre cr\u00e9\u00e9 pour charger les modules R et GCC, exporter `R_LIBS`, et ex\u00e9cuter le script R avec `R CMD BATCH --no-save --no-restore test_foreach.R`, puis soumettre avec `sbatch job_foreach.sh`."
  },
  {
    "question": "Quel type de grappe est cr\u00e9\u00e9 avec `makeCluster` et `type = \"PSOCK\"` ?",
    "answer": "Le type de grappe `PSOCK` ex\u00e9cute des commandes par des connexions SSH vers les n\u0153uds."
  },
  {
    "question": "Comment cr\u00e9er un cluster avec `makeCluster` en sp\u00e9cifiant les n\u0153uds ?",
    "answer": "Il faut d'abord obtenir une liste des noms de n\u0153uds (par exemple, `nodeslist = unlist(strsplit(Sys.getenv(\"NODESLIST\"), split=\" \"))`), puis cr\u00e9er le cluster avec `cl = makeCluster(nodeslist, type = \"PSOCK\")`."
  },
  {
    "question": "Comment enregistrer un cluster cr\u00e9\u00e9 avec `makeCluster` pour l'utiliser avec `doParallel` ?",
    "answer": "Le cluster est enregistr\u00e9 avec `registerDoParallel(cl)`."
  },
  {
    "question": "Comment lib\u00e9rer les ressources d'un cluster R cr\u00e9\u00e9 avec `makeCluster` ?",
    "answer": "Il ne faut pas oublier d'utiliser `stopCluster(cl)` pour lib\u00e9rer les ressources du cluster."
  },
  {
    "question": "Comment la variable d'environnement `NODESLIST` est-elle d\u00e9finie dans le script SLURM pour `makeCluster` ?",
    "answer": "`NODESLIST` est d\u00e9finie en ex\u00e9cutant `export NODESLIST=$(echo $(srun hostname | cut -f 1 -d '.'))` pour obtenir les noms des n\u0153uds."
  },
  {
    "question": "Comment s'assurer que les processus d'une t\u00e2che SLURM sont r\u00e9partis sur diff\u00e9rents n\u0153uds avec `makeCluster` ?",
    "answer": "Pour r\u00e9partir les processus sur diff\u00e9rents n\u0153uds, il faut ajouter la ligne `#SBATCH --ntasks-per-node=2` (ou le nombre de t\u00e2ches par n\u0153ud souhait\u00e9) au script SLURM."
  }
]