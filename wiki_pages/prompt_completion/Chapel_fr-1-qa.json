[
  {
    "question": "Qu'est-ce que Chapel ?",
    "answer": "Chapel est un langage de programmation parall\u00e8le compil\u00e9 de haut niveau \u00e0 usage g\u00e9n\u00e9ral, dot\u00e9 d'abstractions int\u00e9gr\u00e9es pour le parall\u00e9lisme \u00e0 m\u00e9moire partag\u00e9e et distribu\u00e9e."
  },
  {
    "question": "Quels sont les deux styles de programmation parall\u00e8le offerts par Chapel ?",
    "answer": "Chapel offre deux styles : (1) le parall\u00e9lisme de t\u00e2ches, o\u00f9 le parall\u00e9lisme est sp\u00e9cifi\u00e9 par programmation, et (2) le parall\u00e9lisme de donn\u00e9es, o\u00f9 le parall\u00e9lisme s'effectue en r\u00e9alisant les m\u00eames calculs sur des sous-ensembles de donn\u00e9es."
  },
  {
    "question": "Comment le parall\u00e9lisme de t\u00e2ches est-il mis en \u0153uvre dans Chapel ?",
    "answer": "Dans Chapel, le parall\u00e9lisme de t\u00e2ches se fait par des t\u00e2ches sp\u00e9cifi\u00e9es par programmation."
  },
  {
    "question": "Comment le parall\u00e9lisme de donn\u00e9es est-il mis en \u0153uvre dans Chapel ?",
    "answer": "Dans Chapel, le parall\u00e9lisme de donn\u00e9es se fait en effectuant les m\u00eames calculs sur des sous-ensembles de donn\u00e9es qui peuvent se trouver dans la m\u00e9moire partag\u00e9e d'un n\u0153ud unique ou \u00eatre distribu\u00e9s sur plusieurs n\u0153uds."
  },
  {
    "question": "Pourquoi Chapel est-il consid\u00e9r\u00e9 comme un outil id\u00e9al pour l'apprentissage de la programmation parall\u00e8le pour le calcul de haute performance ?",
    "answer": "Ses abstractions de haut niveau le rendent id\u00e9al pour l'apprentissage de la programmation parall\u00e8le pour le calcul de haute performance, car il est intuitif et fusionne la facilit\u00e9 d'utilisation de Python avec les performances des langages compil\u00e9s comme C et Fortran."
  },
  {
    "question": "Comment Chapel se compare-t-il \u00e0 MPI en termes de longueur de code pour les blocs parall\u00e8les ?",
    "answer": "Les blocs parall\u00e8les qui prennent g\u00e9n\u00e9ralement des dizaines de lignes de code MPI peuvent \u00eatre exprim\u00e9s en seulement quelques lignes de code Chapel."
  },
  {
    "question": "Chapel est-il un langage open source ?",
    "answer": "Oui, Chapel est open source."
  },
  {
    "question": "Sur quels syst\u00e8mes d'exploitation Chapel peut-il fonctionner ?",
    "answer": "Chapel peut fonctionner sur n'importe quel syst\u00e8me d'exploitation de type Unix."
  },
  {
    "question": "Quelle est la prise en charge mat\u00e9rielle de Chapel ?",
    "answer": "Chapel prend en charge une large gamme de mat\u00e9riel, des ordinateurs portables aux grands syst\u00e8mes de CHP."
  },
  {
    "question": "Quelle est une limitation actuelle de Chapel concernant les biblioth\u00e8ques ?",
    "answer": "Chapel a une base d'utilisateurs relativement petite, donc de nombreuses biblioth\u00e8ques qui existent pour C, C++ et Fortran n'ont pas encore \u00e9t\u00e9 impl\u00e9ment\u00e9es dans Chapel."
  },
  {
    "question": "O\u00f9 peut-on trouver plus d'informations sur Chapel ?",
    "answer": "Pour plus d'information, vous pouvez consulter les webinaires Chapel sur westgrid.github.io."
  },
  {
    "question": "Quel module est utilis\u00e9 pour les calculs simples sur un n\u0153ud unique et en m\u00e9moire partag\u00e9e ?",
    "answer": "Le module `chapel-multicore` est utilis\u00e9 pour ces calculs."
  },
  {
    "question": "Comment tester si votre code Chapel fonctionne en s\u00e9quentiel sur un n\u0153ud unique ?",
    "answer": "Chargez `gcc/12.3` et `chapel-multicore/2.4.0`, puis utilisez `salloc --time=0:30:0 --ntasks=1 --mem-per-cpu=3600 --account=def-someprof`, compilez avec `chpl test.chpl -o test` et ex\u00e9cutez avec `./test`."
  },
  {
    "question": "Comment ex\u00e9cuter un code Chapel avec plusieurs c\u0153urs sur un m\u00eame n\u0153ud ?",
    "answer": "Chargez `gcc/12.3` et `chapel-multicore/2.4.0`, puis utilisez `salloc --time=0:30:0 --ntasks=1 --cpus-per-task=3 --mem-per-cpu=3600 --account=def-someprof`, compilez avec `chpl test.chpl -o test` et ex\u00e9cutez avec `./test`."
  },
  {
    "question": "Quelle est la proc\u00e9dure recommand\u00e9e pour les t\u00e2ches de production avec Chapel sur un n\u0153ud unique ?",
    "answer": "Pour les t\u00e2ches de production, il est recommand\u00e9 de pr\u00e9parer un script de soumission de t\u00e2che et de le soumettre avec `sbatch`."
  },
  {
    "question": "Quel module doit \u00eatre charg\u00e9 pour les calculs distribu\u00e9s sur plusieurs n\u0153uds et avec une m\u00e9moire hybride sur les grappes InfiniBand ?",
    "answer": "Pour ces t\u00e2ches, vous devez charger le module `chapel-ofi`."
  },
  {
    "question": "Quel est le but du code `probeLocales.chpl` ?",
    "answer": "Le code `probeLocales.chpl` imprime l'information de base au sujet des n\u0153uds disponibles dans votre t\u00e2che."
  },
  {
    "question": "Quelles informations de base sont affich\u00e9es par `probeLocales.chpl` sur chaque locale ?",
    "answer": "Il affiche l'ID de la locale, son nom, le nombre de c\u0153urs de processeur, la quantit\u00e9 de m\u00e9moire physique en GB, et le parall\u00e9lisme maximal."
  },
  {
    "question": "Quel module est n\u00e9cessaire pour ex\u00e9cuter `probeLocales.chpl` sur une grappe InfiniBand ?",
    "answer": "Pour ex\u00e9cuter ce code sur une grappe InfiniBand, vous devez charger le module `chapel-ucx`."
  },
  {
    "question": "Comment lancer une t\u00e2che interactive multi-n\u0153uds avec `chapel-ucx` sur une grappe InfiniBand ?",
    "answer": "Chargez `gcc/12.3` et `chapel-ucx/2.4.0`, puis utilisez `salloc --time=0:30:0 --nodes=4 --cpus-per-task=3 --mem-per-cpu=3500 --account=def-someprof`."
  }
]