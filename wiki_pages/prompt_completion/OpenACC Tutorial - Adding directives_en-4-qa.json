[
  {
    "question": "What is the NVIDIA Visual Profiler (NVVP)?",
    "answer": "The NVIDIA Visual Profiler (NVVP) is a cross-platform graphical analyzing tool for applications written with OpenACC and CUDA C/C++ instructions."
  },
  {
    "question": "What happens if an executable not using the GPU is profiled with NVVP?",
    "answer": "If the executable is not using the GPU, you will get no result from the NVIDIA Visual Profiler."
  },
  {
    "question": "How can you launch the NVIDIA Visual Profiler from a terminal?",
    "answer": "First, load the necessary modules by running `module load cuda/11.7 java/1.8`, then launch it with the command `nvvp` (or `nvvp &` to run in the background)."
  },
  {
    "question": "What initial step is required after launching NVVP for the first time?",
    "answer": "After the NVVP startup window, you are prompted for a 'Workspace' directory; you should replace 'home' with 'scratch' in the suggested path and then click 'OK'."
  },
  {
    "question": "What type of executable should be selected when setting up a new session in NVVP?",
    "answer": "You should select an executable built from codes written with OpenACC and CUDA C/C++ instructions."
  },
  {
    "question": "What profiling option should be selected in NVVP when setting up a new session?",
    "answer": "Below the 'Arguments' editor, you should select the profiling option 'Profile current process only'."
  },
  {
    "question": "What does NVVP generate after profiling an application?",
    "answer": "NVVP will run the program and generate a timeline of the execution."
  },
  {
    "question": "What common issue is often observed in the NVVP timeline when porting code from CPU to GPU?",
    "answer": "Almost all of the run time is often spent transferring data between the host and the device."
  },
  {
    "question": "What is the `parallel loop` directive in OpenACC?",
    "answer": "The `parallel loop` directive is a prescriptive approach to porting code, formed by combining the `parallel` and `loop` directives."
  },
  {
    "question": "How does the `parallel loop` directive differ from the `kernels` directive in its approach?",
    "answer": "The `kernels` directive uses a descriptive approach, letting the compiler analyze and decide, while `parallel loop` uses a prescriptive approach, forcing the compiler to perform the loop in parallel."
  },
  {
    "question": "What does the 'prescriptive' nature of `parallel loop` imply about the `independent` clause?",
    "answer": "Since `parallel loop` is a prescriptive directive, it forces the compiler to perform the loop in parallel, meaning the `independent` clause is implicit within a parallel region."
  },
  {
    "question": "What additional clauses are needed to manage data scope with the `parallel loop` directive?",
    "answer": "The `private` and `reduction` clauses are needed to control how data flows through a parallel region."
  },
  {
    "question": "What is the purpose of the `private` clause in OpenACC?",
    "answer": "With the `private` clause, a copy of the variable is made for each loop iteration, making the value of the variable independent from other iterations."
  },
  {
    "question": "What does the `reduction` clause do in OpenACC?",
    "answer": "With the `reduction` clause, the values of a variable in each iteration will be 'reduced' to a single value, supporting operations like addition (+), multiplication (*), maximum (max), and minimum (min)."
  },
  {
    "question": "Why are `private` and `reduction` clauses not explicitly required with the `kernels` directive?",
    "answer": "These clauses were not required with the `kernels` directive because the `kernels` directive handles this data management automatically."
  },
  {
    "question": "What are the programmer's responsibilities when using the `parallel loop` directive?",
    "answer": "When using the `parallel loop` directive, it is the programmer's responsibility to ensure that parallelism is safe."
  },
  {
    "question": "What are the advantages of using the `parallel loop` directive?",
    "answer": "The `parallel loop` directive enables parallelization of sections that the compiler may miss and provides a straightforward path from OpenMP."
  },
  {
    "question": "What are the compiler's responsibilities when using the `kernels` directive?",
    "answer": "When using the `kernels` directive, it is the compiler's responsibility to analyze the code and determine what is safe to parallelize."
  },
  {
    "question": "What are the advantages of using the `kernels` directive?",
    "answer": "The `kernels` directive allows a single directive to cover a large area of code and gives the compiler more room to optimize."
  },
  {
    "question": "Which OpenACC directive, `parallel loop` or `kernels`, offers more flexibility for compiler optimization?",
    "answer": "The `kernels` directive generally offers the compiler more room to optimize because it is a descriptive directive."
  }
]