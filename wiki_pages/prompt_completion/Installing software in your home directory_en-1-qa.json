[
  {
    "question": "How can users get academic software installed on Alliance systems?",
    "answer": "Users can email Alliance support staff, provide them with a URL to the software, and ask them to install it. If license terms and technical requirements are met, it will be made available."
  },
  {
    "question": "How do users access software installed by Alliance staff?",
    "answer": "Users will be able to access the software via a `module load` command."
  },
  {
    "question": "Are users allowed to install software in their own home or project space?",
    "answer": "Yes, users are permitted to install software in their own home space or project space."
  },
  {
    "question": "What are reasons a user might choose to install software in their own space?",
    "answer": "Users might choose to do this if they plan to make their own modifications to the code, or if they wish to evaluate it quickly."
  },
  {
    "question": "What is a very common instruction pattern for installing software?",
    "answer": "A very common instruction pattern is `configure; make; make install`, which typically involves running `./configure`, `make`, and `make install`."
  },
  {
    "question": "What are some variations of the `configure; make; make install` instruction pattern?",
    "answer": "Variations include `cmake .` replacing `./configure`, and `sudo make install` replacing `make install`."
  },
  {
    "question": "Why might the `make install` step fail during software installation?",
    "answer": "`make install` might fail because the package expects to be able to write to `/usr/local` or some other shared area in the file system, which users typically do not have write access to."
  },
  {
    "question": "Why will `sudo make install` always fail on Alliance systems?",
    "answer": "`sudo make install` will always fail because `sudo` is a request for \"root\" or administrator privileges, which users do not have on these systems."
  },
  {
    "question": "What is the usual solution for `make install` failures related to permissions?",
    "answer": "The usual solution is to supply a `--prefix` flag at the `configure` step to direct the installation to a directory of your choice, for example: `./configure --prefix=/my/project/directory/some-package && make && make install`."
  },
  {
    "question": "Who should be contacted if installation errors other than `make install` failures arise?",
    "answer": "If other errors arise, users should contact `support@computecanada.ca`."
  },
  {
    "question": "What is the simplest way to use a library on an Alliance system?",
    "answer": "The simplest way to make use of a library on an Alliance system is to first load the corresponding module using a command like `module load library_name/x.y.z`."
  },
  {
    "question": "How do you include a loaded library during the link phase of a build process?",
    "answer": "You can modify the link phase to include the library, for example, by using `gcc -o my_prog file1.o file2.o -lnetcdf` to link with the NetCDF library."
  },
  {
    "question": "What prefix is needed for the library name in the link line?",
    "answer": "The link line needs to contain `-l` prefixed to the library name (e.g., `-lnetcdf`)."
  },
  {
    "question": "When is it necessary to load a library module?",
    "answer": "You need to load the library module not only during the building of the software, but also when you wish to run this software."
  },
  {
    "question": "What environment variables are set when a library module is loaded?",
    "answer": "Loading a library module will set environment variables `CPATH` and `LIBRARY_PATH`."
  },
  {
    "question": "What do the `CPATH` and `LIBRARY_PATH` environment variables point to?",
    "answer": "These environment variables point to the location of the library itself and its header files."
  },
  {
    "question": "How do compilers utilize `CPATH` and `LIBRARY_PATH`?",
    "answer": "Most compilers (like Intel and GCC) support these environment variables and will automatically try the directories listed in them during compilation and linking phases."
  },
  {
    "question": "In what cases might explicit library locations be necessary, even with modules?",
    "answer": "In some cases, particularly with `cmake`, it may be necessary to specify explicitly the location of the library provided by the module."
  },
  {
    "question": "What is the preferred way to specify an explicit library location when using modules?",
    "answer": "The preferred and most robust way is to use an EasyBuild environment variable, `EBROOT...`, instead of manually typing a path."
  },
  {
    "question": "What is an example of specifying a GSL library location using an EasyBuild environment variable for cmake?",
    "answer": "An example is `-DGSL_DIR=$EBROOTGSL` for cmake."
  },
  {
    "question": "What is the construction pattern for EasyBuild environment variables like `EBROOTGSL`?",
    "answer": "The `EBROOT...` environment variables adhere to the construction pattern: `EBROOT` followed by the name of the package, for example `EBROOTGCC`."
  },
  {
    "question": "If software instructions include `apt-get` or `yum`, how should one proceed?",
    "answer": "It is unlikely that you will be able to install it using those instructions. You should look for instructions that say \"to build from source\", or contact `support@computecanada.ca` for assistance."
  }
]