[
  {
    "question": "What is the Distributed Debugging Tool (DDT) primarily used for?",
    "answer": "DDT is primarily intended for debugging parallel MPI codes, but it can also be used with serial, threaded (OpenMP / pthreads), and GPU (CUDA; also mixed MPI and CUDA) programs."
  },
  {
    "question": "Which company developed the DDT debugger?",
    "answer": "The Distributed Debugging Tool (DDT) was developed by Allinea (U.K.)."
  },
  {
    "question": "On which cluster is DDT installed?",
    "answer": "DDT is installed on the Graham cluster."
  },
  {
    "question": "What programming languages does DDT support?",
    "answer": "DDT supports C, C++, and Fortran 77 / 90 / 95 / 2003."
  },
  {
    "question": "Where can the detailed documentation for DDT (User Guide) be found on Graham?",
    "answer": "The detailed documentation (User Guide) for DDT is available as a PDF file on Graham, in ${EBROOTALLINEA}/doc, after loading the corresponding module."
  },
  {
    "question": "What compiler switch is required when compiling code for debugging with DDT?",
    "answer": "The code has to be compiled with the switch -g, which tells the compiler to generate symbolic information required by any debugger."
  },
  {
    "question": "Should compiler optimizations be turned on or off when preparing a program for DDT debugging?",
    "answer": "Normally, all optimizations have to be turned off when preparing a program for DDT debugging."
  },
  {
    "question": "How would you compile a Fortran 77 program named 'program.f' for DDT debugging, ensuring no optimizations?",
    "answer": "You would use the command: f77 -g -O0 -o program program.f"
  },
  {
    "question": "How would you compile an MPI C program named 'code.c' for DDT debugging, ensuring no optimizations?",
    "answer": "You would use the command: mpicc -g -O0 -o code code.c"
  },
  {
    "question": "What command is used to compile the CUDA part of a program (e.g., 'cuda_code.cu') for DDT debugging?",
    "answer": "The CUDA part (*.cu files) can be compiled using nvcc with the command: nvcc -g -G -c cuda_code.cu"
  },
  {
    "question": "How do you link a serial C program ('main.c') with a pre-compiled CUDA object file ('cuda_code.o') for DDT debugging?",
    "answer": "You would link them using the command: cc -g main.c cuda_code.o -lcudart"
  },
  {
    "question": "How do you link a mixed MPI/CUDA program ('main.c') with a pre-compiled CUDA object file ('cuda_code.o') for DDT debugging?",
    "answer": "You would link them using the command: mpicc -g main.c cuda_code.o -lcudart"
  },
  {
    "question": "What type of application is DDT, and what setup is required to run it on Graham?",
    "answer": "DDT is a GUI application, so one has to set up the environment properly to run X-windows (graphical) applications on Graham."
  },
  {
    "question": "What application is recommended for running X-windows applications on Microsoft Windows for DDT?",
    "answer": "For Microsoft Windows, use the free MobaXTerm app to run X-windows applications for DDT."
  },
  {
    "question": "What application is required on a Mac to run X-windows applications for DDT?",
    "answer": "On a Mac, you need to install the free app XQuartz to run X-windows applications for DDT."
  },
  {
    "question": "What argument should be added to ssh commands for X11 tunneling when launching DDT?",
    "answer": "In all cases, add '-Y' to all your ssh commands, for X11 tunneling."
  },
  {
    "question": "What command is used to allocate a compute node for debugging CPU codes with DDT, including X11 forwarding?",
    "answer": "You can use `salloc -A account_name --x11 --time=0-3:00 --mem-per-cpu=4G --ntasks=4` for CPU codes."
  },
  {
    "question": "What command is used to allocate a compute node with a GPU for debugging GPU codes with DDT, including X11 forwarding?",
    "answer": "You can use `salloc -A account_name --x11 --time=0-3:00 --mem-per-cpu=4G --ntasks=1 --gres=gpu:1` for GPU codes."
  },
  {
    "question": "How do you load the DDT module for CPU codes?",
    "answer": "Load the corresponding DDT module with: `module load allinea-cpu`."
  },
  {
    "question": "How do you load the DDT module for GPU codes?",
    "answer": "Load the corresponding DDT module with: `module load allinea-gpu`."
  },
  {
    "question": "What command must be executed for MPI codes to enable the Message queue display feature in DDT?",
    "answer": "For MPI codes, one must execute `export OMPI_MCA_pml=ob1` or else the Message queue display feature will not work."
  },
  {
    "question": "How do you launch DDT to debug a program?",
    "answer": "To debug a code, simply type `ddt program [optional arguments]`."
  },
  {
    "question": "What type of interface does DDT use for its components?",
    "answer": "DDT uses a tabbed-document interface, and each component is a dockable window."
  },
  {
    "question": "How can user-modified parameters and windows be saved in DDT?",
    "answer": "Some of the user-modified parameters and windows are saved by right-clicking and selecting a save option in the corresponding window (Groups; Evaluations; Breakpoints etc)."
  },
  {
    "question": "Does DDT allow saving and loading entire debugging sessions?",
    "answer": "Yes, DDT has the ability to load and save all options concurrently, minimizing inconvenience in restarting sessions. Saving a session stores things like process groups and contents of the Evaluate window."
  },
  {
    "question": "How does DDT locate the source code when a debugging session begins?",
    "answer": "When DDT begins a session, source code is automatically found from the information compiled in the executable."
  },
  {
    "question": "How can you find occurrences of an expression in the currently visible source file in DDT?",
    "answer": "The 'Find' dialog, found from the 'Search' menu, will find occurrences of an expression in the currently visible source file."
  },
  {
    "question": "How can you search for an expression across all source and header files associated with your program in DDT?",
    "answer": "The 'Find In Files' dialog, found from the 'Search' menu, searches all source and header files associated with your program."
  },
  {
    "question": "How can a user go directly to a specific line of code in DDT?",
    "answer": "DDT has a 'Goto line' function, available in the 'Search' menu or by using 'Ctrl-G', which enables the user to go directly to a line of code."
  },
  {
    "question": "What are the three predefined process groups in DDT?",
    "answer": "The three predefined groups are: All, Root, and Workers. (Newest DDT versions only have one group - All)."
  },
  {
    "question": "How can users control the stepping through a program in DDT?",
    "answer": "Users can step through a program using 'Play/Continue', 'Pause', 'Step Into', 'Step Over', and 'Step Out' commands."
  },
  {
    "question": "Where are all breakpoints listed in DDT?",
    "answer": "All breakpoints are listed under the breakpoints tab."
  },
  {
    "question": "Can breakpoints be made conditional in DDT?",
    "answer": "Yes, breakpoints can easily be made conditional in DDT."
  },
  {
    "question": "How can processes in a group be synchronized in DDT?",
    "answer": "Processes in a group can be synchronized using the 'Run to here' command, accessed via a right mouse click."
  },
  {
    "question": "How can users view stacks in parallel in DDT?",
    "answer": "Users can view stacks in parallel using the 'Stacks' tab, which shows a tree of functions merged from every process in the group."
  },
  {
    "question": "What signals will DDT stop on by default for signal handling?",
    "answer": "DDT will stop on the following signals: SIGSEGV (segmentation fault), SIGFPE (Floating Point Exception), SIGPIPE (Broken Pipe), and SIGILL (Illegal Instruction)."
  },
  {
    "question": "What extra compiler option is required for Intel compilers to enable Floating Point Exception (FPE) handling in DDT?",
    "answer": "To enable FPE handling with Intel compilers, the extra compiler option `-fp0` is required."
  },
  {
    "question": "How can you view variables for the current line(s) in DDT?",
    "answer": "Variables for the current line(s) can be viewed in the 'Current Line' tab, by clicking and dragging for multiple lines."
  },
  {
    "question": "Where can you find all local variables for a process in DDT?",
    "answer": "All local variables for the process are shown in the 'Locals' tab."
  },
  {
    "question": "What is the purpose of the 'Evaluate' window in DDT?",
    "answer": "The 'Evaluate' window can be used to view values for arbitrary expressions and global variables."
  },
  {
    "question": "How can you change data values in DDT?",
    "answer": "Data values can be changed by right-clicking and selecting 'Edit value' in the Evaluate window."
  },
  {
    "question": "How can pointers be examined in DDT's 'Evaluate' window?",
    "answer": "Pointers can be examined by dragging them into the 'Evaluate' window, and then right-clicking to choose to view them as Vector, Reference, or Dereference."
  },
  {
    "question": "How are multi-dimensional arrays visualized in DDT?",
    "answer": "Multi-dimensional arrays can be viewed in the 'Variable View', and there is a 'Multi-Dimensional Array viewer' for visualization of a 2-D slice using OpenGL."
  },
  {
    "question": "How can you perform a cross-process comparison of variables in DDT?",
    "answer": "Cross-Process Comparison can be done by right-clicking on a variable name, or from the 'View' menu by selecting 'Cross-Process/Thread Comparison' and typing in any valid expression."
  },
  {
    "question": "What are the three modes available for cross-process/thread comparison in DDT?",
    "answer": "The three modes available for cross-process/thread comparison are Compare, Statistics, and Visualize."
  },
  {
    "question": "How do you access the Message Queues feature in DDT?",
    "answer": "The Message Queues feature can be accessed via 'View -> Message Queues' (older versions) or 'Tools -> Message Queues' (newer versions) in the control panel."
  },
  {
    "question": "What does the Message Queues feature in DDT provide?",
    "answer": "The Message Queues feature produces both a graphical view and a table for all active communications."
  },
  {
    "question": "What kind of MPI problems can DDT's Message Queues feature help debug?",
    "answer": "The Message Queues feature helps to debug MPI problems such as deadlocks."
  },
  {
    "question": "What capabilities does DDT's Memory Debugging feature offer?",
    "answer": "DDT's Memory Debugging feature can intercept memory allocation and de-allocation calls and perform lots of complex heap- and bounds-checking."
  },
  {
    "question": "Is memory debugging enabled by default in DDT?",
    "answer": "No, memory debugging is off by default and can be turned on before starting a debugging session in Advanced settings."
  },
  {
    "question": "How can you check if a pointer is valid in DDT?",
    "answer": "In the Evaluate window, you can right-click and select 'Check pointer is valid' to check if a pointer is valid."
  },
  {
    "question": "How can memory leaks be detected in DDT?",
    "answer": "Memory leaks can be detected using the 'View->Current Memory Usage' window (or 'Tools->Current Memory Usage' in newer versions), which shows current memory usage across processes and allows viewing allocation details and a table view."
  },
  {
    "question": "Where can overall memory statistics be found in DDT?",
    "answer": "Overall memory statistics can be found via the menu option 'View->Overall Memory Stats' (or 'Tools->Overall Memory Stats' in newer versions)."
  },
  {
    "question": "What are some of the OpenMP debugging functionalities offered by DDT?",
    "answer": "DDT offers OpenMP functionalities such as single-click access to threads, viewing stacks in parallel, setting thread-specific breakpoints, and comparing expressions across threads."
  },
  {
    "question": "What are the limitations for debugging mixed MPI/CUDA code with DDT regarding nodes and GPUs?",
    "answer": "When debugging mixed MPI/CUDA code with DDT, it can only use one CPU and one GPU per node, up to 8 nodes."
  }
]