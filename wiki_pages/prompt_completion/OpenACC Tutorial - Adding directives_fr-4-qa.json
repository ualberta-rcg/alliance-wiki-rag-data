[
  {
    "question": "What is the primary purpose of the `restrict` keyword in C99?",
    "answer": "The `restrict` keyword in C99 is used to inform the compiler that certain pointers are not aliases, which helps in preventing false dependencies in loops and allows for further optimizations."
  },
  {
    "question": "What guarantee does a programmer make when declaring a pointer as `restrict`?",
    "answer": "By declaring a pointer as `restrict`, the programmer guarantees that only that specific pointer or a value derived from it (e.g., `ptr + 1`) will access the object it refers to, for the pointer's lifetime."
  },
  {
    "question": "What are the consequences if a programmer fails to honor the `restrict` guarantee?",
    "answer": "If a programmer fails to uphold the obligation of the `restrict` keyword, the behavior of the program is not defined."
  },
  {
    "question": "How can a programmer explicitly instruct the compiler to treat loop iterations as independent in OpenACC?",
    "answer": "A programmer can explicitly ensure the compiler treats loop iterations independently by using the `<tt>independent</tt>` clause within an OpenACC directive."
  },
  {
    "question": "What kind of directive is the `independent` clause in OpenACC?",
    "answer": "The `independent` clause is a 'prescriptive' directive, meaning the compiler is compelled to execute it, and its own analysis will not override this instruction."
  },
  {
    "question": "How did the addition of `__restrict` affect the compilation of the matrix-vector product example?",
    "answer": "After adding `__restrict` to the `Acoefs`, `xcoefs`, and `ycoefs` pointers, the compiler was able to parallelize both the outer loop (`#pragma acc loop gang`) and the inner loop (`#pragma acc loop vector`)."
  },
  {
    "question": "What was the initial performance observation when comparing the OpenACC version of the matrix-vector product to the original CPU version?",
    "answer": "The OpenACC version took approximately four times longer to execute (115.068931s) compared to the original CPU version (29.894881s), despite the code being ported to the GPU."
  },
  {
    "question": "What is NVIDIA Visual Profiler (NVVP)?",
    "answer": "NVIDIA Visual Profiler (NVVP) is a graphical profiler for applications written with OpenACC and CUDA C/C++ directives."
  },
  {
    "question": "Under what condition will NVVP not provide profiling results?",
    "answer": "NVVP will not provide any results if the executable being profiled does not use the GPU."
  },
  {
    "question": "What is a common bottleneck identified by NVVP when code is ported from a CPU to a GPU?",
    "answer": "NVVP commonly identifies that the transfer of data between the host (CPU) and the device (GPU) occupies the largest portion of the execution time."
  },
  {
    "question": "How do you launch NVVP from a terminal after loading the necessary modules?",
    "answer": "After loading the `cuda/11.7` and `java/1.8` modules, NVVP can be launched from a terminal using the command `nvvp &`."
  },
  {
    "question": "What is the fundamental difference in approach between the OpenACC `kernels` directive and the `parallel loop` directive?",
    "answer": "The `kernels` directive is 'descriptive', allowing the compiler to analyze and optimize the code as it deems best, whereas `parallel loop` is 'prescriptive', explicitly forcing the compiler to execute the loop in parallel."
  },
  {
    "question": "What clause is implicitly included when using the `parallel loop` directive in OpenACC?",
    "answer": "The `<tt>independent</tt>` clause is implicitly included within a parallel zone when using the `parallel loop` directive."
  },
  {
    "question": "What are the common clauses required with `parallel loop` for managing data flow within a parallel region?",
    "answer": "The `private` and `reduction` clauses are commonly required with `parallel loop` to manage data flow within a parallel region."
  },
  {
    "question": "Why are `private` and `reduction` clauses generally not needed with the OpenACC `kernels` directive?",
    "answer": "These clauses are not necessary with the `kernels` directive because the compiler automatically handles the work of managing data flow, including reductions and privatization."
  },
  {
    "question": "What is the function of the `reduction` clause in OpenACC?",
    "answer": "The `reduction` clause ensures that variable values from each iteration are combined ('reduced') into a single value, typically for operations like addition (+), multiplication (*), maximum (max), or minimum (min)."
  },
  {
    "question": "What was the total execution time for the original, non-OpenACC code on a GPU node?",
    "answer": "The original code executed in 29.894881 seconds on a GPU node."
  },
  {
    "question": "What was the total execution time for the OpenACC version of the code?",
    "answer": "The OpenACC version of the code executed in 115.068931 seconds."
  }
]