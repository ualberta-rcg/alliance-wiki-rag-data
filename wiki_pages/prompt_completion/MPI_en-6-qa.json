[
  {
    "question": "What does it mean for MPI_Send and MPI_Recv to be 'blocking calls'?",
    "answer": "MPI_Send is a blocking call, meaning it will not return until it's safe for the calling module to modify the provided message buffer. MPI_Recv is also a blocking call and will not return until the entire message contents are available in the caller's message buffer."
  },
  {
    "question": "How does MPI library buffering affect MPI_Send and MPI_Recv operations?",
    "answer": "Buffering does not affect MPI_Recv; it always blocks until data is received. For MPI_Send, if the library provides an internal buffer, the call may not block because the message can be copied out, making it safe for the user to modify the original data location."
  },
  {
    "question": "What is considered an 'unsafe' MPI program?",
    "answer": "An 'unsafe' MPI program is one whose correctness relies on the MPI library providing buffering for `MPI_Send` operations. If buffering is not provided or if message buffers fill up, such a program could deadlock."
  },
  {
    "question": "Provide an example of a deadlock scenario in MPI programming with pseudo-code.",
    "answer": "A deadlock can occur if two processes (e.g., rank 0 and rank 1) both attempt to call MPI_Recv before their corresponding MPI_Send. For instance: `if (rank == 0) { MPI_Recv(from 1); MPI_Send(to 1); } else if (rank == 1) { MPI_Recv(from 0); MPI_Send(to 0); }`."
  },
  {
    "question": "How can an MPI program be considered 'unsafe' when processes send before receiving?",
    "answer": "An MPI program where processes call MPI_Send before MPI_Recv (e.g., `if (rank == 0) { MPI_Send(to 1); MPI_Recv(from 1); } else if (rank == 1) { MPI_Send(to 0); MPI_Recv(from 0); }`) is unsafe. It might work with buffering, but if the library is unbuffered or buffers fill, it will block on sends and deadlock."
  },
  {
    "question": "What is a 'safe' MPI program?",
    "answer": "A 'safe' MPI program is one that does not rely on a buffered implementation to function correctly. This typically involves ensuring that send and receive operations are properly paired to avoid deadlock, even if there's no buffering."
  },
  {
    "question": "How can the 'Hello, World!' program be modified to be a 'safe' MPI program?",
    "answer": "To make the 'Hello, World!' program safe, an odd-even pairing communication strategy can be used. All even-ranked processes execute a `send` followed by a `receive`, while all odd-ranked processes execute a `receive` followed by a `send`. This ensures sends and receives are properly paired, preventing deadlock."
  },
  {
    "question": "What is the C language pseudo-code for a safe MPI program in a circular communication pattern?",
    "answer": "For a safe MPI program with a circular communication where `sendto = (rank + 1) % size;` and `recvfrom = ((rank + size) - 1) % size;`, the C pseudo-code would be: `if (!(rank % 2)) { MPI_Send(outbuf, ...); MPI_Recv(inbuf, ...); } else { MPI_Recv(inbuf, ...); MPI_Send(outbuf, ...); }`."
  }
]