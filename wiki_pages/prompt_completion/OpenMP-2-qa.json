[
  {
    "question": "What is an advantage of using 'dynamic', 'guided', or 'auto' scheduling in OpenMP?",
    "answer": "These scheduling types allow a better load-balancing of threads as they dynamically adjust the work assigned to each thread."
  },
  {
    "question": "What is a disadvantage of 'dynamic', 'guided', or 'auto' OpenMP scheduling?",
    "answer": "The programmer does not know in advance on which core a certain thread executes, or which memory it will need to access, making it impossible to predict memory-core affinity."
  },
  {
    "question": "In what type of architecture is unpredictable memory-core affinity particularly problematic?",
    "answer": "It can be particularly problematic in a NUMA (Non-Uniform Memory Access) architecture."
  },
  {
    "question": "What is the purpose of the `OMP_STACKSIZE` environment variable?",
    "answer": "The `OMP_STACKSIZE` environment variable specifies the size of the stack for each thread created by the OpenMP runtime."
  },
  {
    "question": "How is the stack size determined for the main OpenMP thread versus additional threads?",
    "answer": "The main OpenMP thread gets its stack size from the execution shell, while `OMP_STACKSIZE` applies to each additional thread created at runtime."
  },
  {
    "question": "What is the implied value of `OMP_STACKSIZE` if it is not set?",
    "answer": "If `OMP_STACKSIZE` is not set, its implied value will be 4M."
  },
  {
    "question": "What can occur if an OpenMP program runs out of stack memory?",
    "answer": "If your OpenMP code does not have enough stack memory, it might crash with a segmentation fault error message."
  },
  {
    "question": "How do environment variables specific to Intel and GNU compilers typically start?",
    "answer": "Environment variables specific to the Intel compiler start with `KMP_` whereas those specific to Gnu start with `GOMP_`."
  },
  {
    "question": "Which OpenMP variables are important for optimal memory access performance, especially in NUMA architectures?",
    "answer": "For optimal performance regarding memory access, it is important to set the `OMP_PROC_BIND` variable as well as affinity variables like `KMP_AFFINITY` for Intel, and `GOMP_CPU_AFFINITY` for GNU compilers."
  },
  {
    "question": "Why is setting `OMP_PROC_BIND` and affinity variables important for performance?",
    "answer": "Setting these variables prevents the movement of OpenMP threads between processors by the operating system, which is particularly important in NUMA architectures."
  },
  {
    "question": "How do you compile a C OpenMP program using GCC?",
    "answer": "You compile it using the command `gcc -O3 -fopenmp ompHello.c -o ompHello`."
  },
  {
    "question": "How do you run a compiled C OpenMP program with 4 threads?",
    "answer": "First, set the number of threads with `export OMP_NUM_THREADS=4`, then run `./ompHello`."
  },
  {
    "question": "How do you compile a Fortran 90 OpenMP program using GFortran?",
    "answer": "You compile it using the command `gfortran -O3 -fopenmp ompHello.f90 -o fomphello`."
  },
  {
    "question": "Where can I find a comprehensive OpenMP tutorial from Lawrence Livermore National Labs?",
    "answer": "Lawrence Livermore National Labs has a comprehensive tutorial on OpenMP at https://computing.llnl.gov/tutorials/openMP."
  },
  {
    "question": "What kind of OpenMP resources does OpenMP.org publish?",
    "answer": "OpenMP.org publishes formal specifications, handy reference cards for C/C++ and Fortran interfaces, and examples."
  }
]