[
  {
    "question": "How can a user change their Julia depot path?",
    "answer": "Users can change their Julia depot path by exporting the `JULIA_DEPOT_PATH` environment variable in their `~/.bashrc` file, for example: `export JULIA_DEPOT_PATH=\"/project/def-bob/alice/julia:$JULIA_DEPOT_PATH\"`."
  },
  {
    "question": "What is the effect of setting the `JULIA_DEPOT_PATH` environment variable?",
    "answer": "Setting `JULIA_DEPOT_PATH` will make Julia preferentially use the specified directory (e.g., `/project/def-bob/alice/julia`). Files in `~/.julia` will still be considered, and `~/.julia` will still be used for certain files like command history."
  },
  {
    "question": "What is recommended to do before moving your Julia depot to a new location?",
    "answer": "It is recommended to remove your existing `~/.julia` depot first if you have one, using the command: `$ rm -rf $HOME/.julia`."
  },
  {
    "question": "What is an alternative method to manage Julia packages and avoid `~/.julia` quota issues, besides changing the depot path?",
    "answer": "An alternative is to create an Apptainer image with a chosen version of Julia and a selection of packages, redirecting `JULIA_DEPOT_PATH` inside the container."
  },
  {
    "question": "What are the benefits of using an Apptainer image for Julia packages?",
    "answer": "Using an Apptainer image can potentially improve I/O performance (by containing many small files in one .sif file), enhance reproducibility, allow testing of Julia nightly builds without altering local installations, and provide complete control for bundling specific dependencies."
  },
  {
    "question": "What is a disadvantage of using Apptainer for Julia compared to standard modules?",
    "answer": "A disadvantage is that you lose the advantage of optimized Julia modules provided on the clusters."
  },
  {
    "question": "How can Julia interact with Python code?",
    "answer": "Julia can interface with Python code using the PyCall.jl package."
  },
  {
    "question": "How should the `PYTHON` environment variable be set when using PyCall.jl with a virtual Python environment?",
    "answer": "The `PYTHON` environment variable should be set to the path of the Python executable within your virtual Python environment, for example: `ENV[\"PYTHON\"] = joinpath(ENV[\"VIRTUAL_ENV\"], \"bin\", \"python\")` after activating the virtual environment."
  },
  {
    "question": "What is strongly advised against when using PyCall.jl on clusters?",
    "answer": "It is strongly advised against using the default PyCall.jl behavior, which installs a Miniconda distribution inside your Julia environment, as Anaconda and similar distributions are not suitable on the clusters."
  },
  {
    "question": "What issues can arise if PyCall.jl defaults to the operating system's Python installation or uses Miniconda without proper configuration?",
    "answer": "This can lead to incompatibilities with the software stack, and the Miniconda installer can create a large number of files within `JULIA_DEPOT_PATH` (if it's `~/.julia`), potentially causing performance and quota issues."
  },
  {
    "question": "Where can users find more detailed information about PyCall.jl?",
    "answer": "More details can be found in the PyCall.jl documentation on GitHub: `https://github.com/JuliaPy/PyCall.jl`."
  },
  {
    "question": "How can a user generate a list of allocated node names for a parallel Julia job?",
    "answer": "A user can generate a list of allocated node names by running the SLURM command `srun hostname -s > hostfile`."
  },
  {
    "question": "How do you start a parallel Julia program on a cluster using a hostfile?",
    "answer": "You can start a parallel Julia program by using the command `julia --machine-file ./hostfile ./pi_p.jl <argument>` which starts one main Julia process and worker processes on the nodes specified in the `hostfile`."
  },
  {
    "question": "How should Julia's MPI be configured for Julia MPI 0.19 or earlier versions?",
    "answer": "For Julia MPI 0.19 or earlier, users need to load `StdEnv` and `julia` modules, then export specific environment variables: `JULIA_MPI_BINARY`, `JULIA_MPI_PATH`, `JULIA_MPI_LIBRARY`, `JULIA_MPI_ABI`, and `JULIA_MPIEXEC`. Afterward, run `import Pkg; Pkg.add(\"MPI\")` inside Julia."
  },
  {
    "question": "How should Julia's MPI be configured for Julia MPI 0.20 or later versions?",
    "answer": "For Julia MPI 0.20 or later, users need to load the `julia` module, create a `[MPIPreferences]` section in their `.julia/environments/vX.Y/LocalPreferences.toml` file with `_format`, `abi`, `binary`, `libmpi`, and `mpiexec` defined. If the section already exists, it should be removed first. Afterward, run `import Pkg; Pkg.add(\"MPIPreferences\"); Pkg.add(\"MPI\")` inside Julia."
  },
  {
    "question": "What should be done if an `[MPIPreferences]` section already exists in `LocalPreferences.toml` when configuring Julia MPI 0.20 or later?",
    "answer": "If an `[MPIPreferences]` section already exists in `LocalPreferences.toml`, it should be edited and removed first before appending the new configuration."
  },
  {
    "question": "How do you run a Julia MPI program (e.g., `hello.jl`) with two processes?",
    "answer": "After configuring MPI, you can run a Julia MPI program with two processes using `module load StdEnv julia; mpirun -np 2 julia hello.jl`."
  },
  {
    "question": "How can a user restrict the number of threads Julia uses?",
    "answer": "A user can restrict the number of threads Julia uses by setting the `JULIA_NUM_THREADS` environment variable, for example, `JULIA_NUM_THREADS=k`."
  },
  {
    "question": "What is a typical choice for the number of Julia threads?",
    "answer": "Setting the number of threads to the number of processors is a typical choice."
  },
  {
    "question": "How can Julia threads be 'pinned' to cores?",
    "answer": "Julia threads can be 'pinned' to cores by setting the `JULIA_EXCLUSIVE` environment variable to any non-zero value."
  },
  {
    "question": "What is the purpose of setting `JULIA_EXCLUSIVE`?",
    "answer": "Setting `JULIA_EXCLUSIVE` takes control of thread scheduling away from the operating system and pins threads to cores, which can improve performance if there is precise information on cache access patterns or if unwelcome OS scheduling patterns are to be avoided."
  },
  {
    "question": "Under what condition does `JULIA_EXCLUSIVE` work effectively?",
    "answer": "`JULIA_EXCLUSIVE` only works if the job has exclusive access to the compute nodes, meaning all available CPU cores were allocated to the job."
  },
  {
    "question": "Why might `JULIA_EXCLUSIVE` not lead to performance improvement with SLURM?",
    "answer": "Since SLURM already pins processes and threads to CPU cores, asking Julia to re-pin threads may not lead to any additional performance improvement."
  },
  {
    "question": "Which environment variable controls when a spinning Julia thread is scheduled to sleep?",
    "answer": "The `JULIA_THREAD_SLEEP_THRESHOLD` environment variable controls the number of nanoseconds after which a spinning thread is scheduled to sleep."
  },
  {
    "question": "How can a spinning Julia thread be prevented from sleeping?",
    "answer": "A spinning Julia thread can be prevented from sleeping by setting `JULIA_THREAD_SLEEP_THRESHOLD` to 'infinite' (as a string)."
  },
  {
    "question": "When might adjusting `JULIA_THREAD_SLEEP_THRESHOLD` be beneficial?",
    "answer": "Adjusting this variable can be useful when many threads are frequently contending for a shared resource, where quicker scheduling out of spinning threads might be preferred, or conversely, in situations of infrequent contention, prohibiting threads from sleeping could result in lower latency."
  },
  {
    "question": "What is the primary programming interface for GPUs in Julia?",
    "answer": "Julia's primary programming interface for GPUs is the CUDA.jl package."
  },
  {
    "question": "How is the CUDA.jl package installed in Julia?",
    "answer": "The CUDA.jl package can be installed using the Julia package manager, typically by running `import Pkg; Pkg.add(\"CUDA\")` after loading appropriate modules."
  },
  {
    "question": "Where should the CUDA.jl package be downloaded?",
    "answer": "The CUDA.jl package should be downloaded on a login node."
  },
  {
    "question": "What environment variable should be set before adding the CUDA.jl package?",
    "answer": "Before adding CUDA.jl, `ENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0` should be set."
  },
  {
    "question": "Where should subsequent GPU-related tasks, after initial CUDA.jl download, be performed?",
    "answer": "Everything that follows the initial download and package addition should be done on a GPU compute node."
  },
  {
    "question": "What issue can arise with the CUDA toolkit downloaded during installation and the installed CUDA driver?",
    "answer": "It is possible that the CUDA toolkit downloaded during installation might not work with the installed CUDA driver."
  },
  {
    "question": "How can the CUDA toolkit/driver compatibility problem be avoided?",
    "answer": "This problem can be avoided by configuring Julia to use the local CUDA toolkit by running `CUDA.set_runtime_version!(v\"version_of_cuda\", local_toolkit=true)` on a GPU node."
  },
  {
    "question": "How can a user verify that Julia is using the correct CUDA version?",
    "answer": "After restarting Julia, a user can verify the CUDA version by running `CUDA.versioninfo()`."
  }
]