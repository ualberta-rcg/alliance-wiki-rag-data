[
  {
    "question": "What is Computational Intensity as defined in the compiler feedback?",
    "answer": "Computational Intensity is a measure of how much work is being done compared to memory operations."
  },
  {
    "question": "How is Computational Intensity calculated?",
    "answer": "Computational Intensity is calculated as the ratio of Compute Operations to Memory Operations."
  },
  {
    "question": "What does a Computational Intensity value of 1.0 or greater indicate?",
    "answer": "An `Intensity` value of 1.0 or greater suggests that the loop might run well on a GPU."
  },
  {
    "question": "What was the Computational Intensity for the `dot` function according to the compiler feedback?",
    "answer": "The `dot` function had a Computational Intensity of 1.00."
  },
  {
    "question": "Why was the loop in the `dot` function not fused, as per the compiler feedback?",
    "answer": "The loop in the `dot` function was not fused because of different loop trip counts."
  },
  {
    "question": "What type of code was generated for the loop containing reductions in the `dot` function?",
    "answer": "Generated vector SIMD code was generated for the loop containing reductions in the `dot` function."
  },
  {
    "question": "What was the Computational Intensity for the `waxpby` function based on the compiler feedback?",
    "answer": "The `waxpby` function had a Computational Intensity of 0.67."
  },
  {
    "question": "What were some reasons the `waxpby` function's loop was not vectorized or fused?",
    "answer": "The `waxpby` function's loop was not fused due to different loop trip counts or a function call before an adjacent loop, and it was not vectorized due to data dependency."
  },
  {
    "question": "What loop optimization was applied to the `waxpby` function's loop?",
    "answer": "The `waxpby` function's loop was unrolled 4 times."
  },
  {
    "question": "Is the accumulation of values in `sum` within the `matvec()` function considered a data dependency?",
    "answer": "No, it's a reduction, and modern compilers are good at optimizing such reductions."
  },
  {
    "question": "What kind of data dependency makes efficient parallelism difficult or impossible?",
    "answer": "Efficient parallelism is very difficult to implement if one loop iteration affects other loop iterations, such as in the Fibonacci sequence where each new value depends on the previous two values."
  },
  {
    "question": "Does the `matvec()` function code have loop iterations that read from and write to the same array such that values are used or overwritten in other iterations?",
    "answer": "No, that does not happen in the `matvec()` function code provided."
  }
]