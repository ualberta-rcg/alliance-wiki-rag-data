[
  {
    "question": "What is 'make' in the context of file building?",
    "answer": "Make is a utility that automatically builds files, such as executables or libraries, from other files, such as source code."
  },
  {
    "question": "How does the 'make' command function?",
    "answer": "The 'make' command interprets and executes instructions within a file named 'makefile', only executing necessary commands to achieve a result without redoing all steps."
  },
  {
    "question": "What kind of information is contained within a makefile?",
    "answer": "A makefile contains information on 'dependencies', indicating how files rely on each other."
  },
  {
    "question": "How does 'make' handle changes in source files that affect object files?",
    "answer": "If a makefile indicates that an object (.o) file depends on a source file, and the source file has changed, 'make' recompiles the source file to update the object file."
  },
  {
    "question": "What is the primary benefit of including all dependencies in a makefile?",
    "answer": "It is not necessary to recompile all files for every modification; the 'make' command recompiles and relinks only what is necessary."
  },
  {
    "question": "What is the main argument given to the 'make' command?",
    "answer": "The main argument of the 'make' command is the 'target'."
  },
  {
    "question": "What are some common types of targets for the 'make' command?",
    "answer": "Targets can be the name of a file make should build, or abstract targets such as 'all', 'test', 'check', 'clean', or 'install'."
  },
  {
    "question": "What happens if you invoke 'make' without specifying a target?",
    "answer": "If 'make' is invoked with no target specified, the typical behavior is to construct everything, which is equivalent to 'make all'."
  },
  {
    "question": "How are the 'test' or 'check' targets typically used?",
    "answer": "The 'test' or 'check' targets are generally used to run tests to validate if the application or compiled library functions correctly, often after building everything with 'make all'."
  },
  {
    "question": "What is the purpose of the 'clean' target?",
    "answer": "The 'clean' target erases all previously compiled binary files, allowing recompilation from scratch."
  },
  {
    "question": "What is the difference between 'clean' and 'distclean' targets?",
    "answer": "The 'clean' target erases files made by 'make', while 'distclean' also deletes files created at configuration time by 'configure' or 'cmake'."
  },
  {
    "question": "How can you specify a custom installation path when using 'make install'?",
    "answer": "You can modify the installation path using an additional 'prefix' parameter, for example: 'make install prefix=$HOME/PROGRAM'."
  },
  {
    "question": "Are the targets 'all', 'test', 'check', 'clean', 'distclean', and 'install' mandatory in every makefile?",
    "answer": "No, these targets are only conventions, and a makefile author could choose another convention."
  },
  {
    "question": "What is the primary goal of the provided example Makefile?",
    "answer": "The goal of the example Makefile is to easily update the compilation of a program containing multiple separated routines by recompiling only modified object files and relinking them into the final program."
  },
  {
    "question": "How can a user adapt the example Makefile to their own program?",
    "answer": "The user should modify the contents of the variables defined within the Makefile, guided by the comments."
  },
  {
    "question": "How do you update the entire program using the example Makefile on the UNIX command line?",
    "answer": "Type 'make' on the UNIX command line to update the whole program."
  },
  {
    "question": "What is the purpose of the 'CompilerName' variable in the example Makefile?",
    "answer": "The 'CompilerName' variable is used to specify the compiler to use, such as 'xlf' for FORTRAN."
  },
  {
    "question": "What information does the 'ObjectFiles' variable hold in the example Makefile?",
    "answer": "The 'ObjectFiles' variable lists all object files (.o) that are needed for the program's compilation."
  },
  {
    "question": "In the example Makefile, what does 'ProgramOut' define?",
    "answer": "The 'ProgramOut' variable defines the name of the final executable file."
  },
  {
    "question": "How does the example Makefile define a rule to build an object file (.o) from a Fortran source file (.f)?",
    "answer": "It uses the rule '.f.o: $(CompilerName) $(CompilationOptions) -c $<', where '$<' represents the source file."
  }
]