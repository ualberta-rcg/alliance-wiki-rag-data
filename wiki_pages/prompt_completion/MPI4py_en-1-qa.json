[
  {
    "question": "What is MPI for Python (mpi4py)?",
    "answer": "MPI for Python (mpi4py) provides Python bindings for the Message Passing Interface (MPI) standard, enabling Python applications to utilize multiple processors on various computing systems like workstations, clusters, and supercomputers."
  },
  {
    "question": "How is mpi4py typically made available?",
    "answer": "mpi4py is available as a module, and not from the wheelhouse like typical Python packages."
  },
  {
    "question": "How can I find the available versions of mpi4py?",
    "answer": "You can find available versions using the command `module spider mpi4py`."
  },
  {
    "question": "How do I get more information about a specific mpi4py version?",
    "answer": "You can look for more information on a specific version by running `module spider mpi4py/X.Y.Z`, where `X.Y.Z` is the exact desired version (e.g., `4.0.0`)."
  },
  {
    "question": "What are the steps to run a 'Hello World' test with mpi4py?",
    "answer": "The steps are: 1. Run a short interactive job using `salloc --account=<your account> --ntasks=5`. 2. Load the necessary modules with `module load mpi4py/4.0.0 python/3.12`. 3. Run the Hello World test using `srun python -m mpi4py.bench helloworld`."
  },
  {
    "question": "Which modules need to be loaded to run the mpi4py Hello World test?",
    "answer": "You need to load `mpi4py/4.0.0` and `python/3.12`."
  },
  {
    "question": "What was the result of the example 'Hello World' test shown in the document?",
    "answer": "The result was processes 0 and 1 running on node1, and processes 2, 3, and 4 running on node3, all printing 'Hello, World! I am process X of 5 on nodeY'."
  },
  {
    "question": "How were the jobs distributed in the 'Hello World' example?",
    "answer": "Two nodes (`node1` and `node3`) were allocated, and the jobs were distributed across the available resources on these nodes."
  },
  {
    "question": "What is the process if mpi4py is a dependency of another package?",
    "answer": "First, deactivate any active Python virtual environment. Then, load the `mpi4py` module. Next, check its visibility with `pip` and accessibility for the loaded Python module. Finally, create a virtual environment and install your packages."
  },
  {
    "question": "Why is it important to deactivate a virtual environment before loading the mpi4py module?",
    "answer": "If a virtual environment is activated, it is important to deactivate it first, then load the mpi4py module, before reactivating your virtual environment, to ensure proper module loading."
  },
  {
    "question": "How can you check if mpi4py is visible to pip after loading the module?",
    "answer": "You can check by running the command `pip list | grep mpi4py`."
  },
  {
    "question": "How can you verify if mpi4py is accessible for your currently loaded Python module?",
    "answer": "You can verify by running `python -c 'import mpi4py'`. If no errors are raised, it is accessible."
  },
  {
    "question": "What is an example Python code for broadcasting a NumPy array using mpi4py?",
    "answer": "The example code initializes a NumPy array on rank 0 and broadcasts it to all other processes, then asserts that the data was received correctly across all ranks."
  },
  {
    "question": "What are the general steps to run mpi4py jobs?",
    "answer": "The general steps are: 1. Write your Python code. 2. Write your submission script. 3. Test your script (preferably in an interactive job). 4. Submit your job to the scheduler."
  },
  {
    "question": "Which modules are loaded in the `submit-mpi4py-distributed.sh` submission script?",
    "answer": "The script loads `StdEnv/2023`, `gcc`, `mpi4py/4.0.0`, and `python/3.12`."
  },
  {
    "question": "How is a virtual environment created and activated on each allocated node within the distributed job submission script?",
    "answer": "A virtual environment is created using `virtualenv --no-download $SLURM_TMPDIR/env` and activated with `source $SLURM_TMPDIR/env/bin/activate` for each allocated node using `srun --ntasks $SLURM_NNODES --tasks-per-node=1`."
  },
  {
    "question": "How do you submit a distributed mpi4py job to the scheduler?",
    "answer": "You submit the job using the command `sbatch submit-mpi4py-distributed.sh`."
  },
  {
    "question": "How can you download the demo example for CUDA-aware MPI with mpi4py?",
    "answer": "You can download the demo example from a login node using `wget https://raw.githubusercontent.com/mpi4py/mpi4py/refs/heads/master/demo/cuda-aware-mpi/use_cupy.py`."
  },
  {
    "question": "Where can additional mpi4py demo examples be found?",
    "answer": "Additional demo examples can be found in the `mpi4py` demo folder on GitHub: `https://github.com/mpi4py/mpi4py/tree/master/demo`."
  },
  {
    "question": "Which modules are loaded in the `submit-mpi4py-gpu.sh` submission script?",
    "answer": "The script loads `StdEnv/2023`, `gcc`, `cuda/12`, `mpi4py/4.0.0`, and `python/3.11`."
  },
  {
    "question": "What Python packages are installed in the virtual environment for a GPU job with mpi4py?",
    "answer": "The packages installed are `pip` (upgraded) and `cupy` and `numba`."
  },
  {
    "question": "What is a common troubleshooting error when mpi4py is not accessible?",
    "answer": "A common error is `ModuleNotFoundError: No module named 'mpi4py'`."
  },
  {
    "question": "What are the possible solutions for a `ModuleNotFoundError: No module named 'mpi4py'`?",
    "answer": "Possible solutions include checking which Python versions are compatible with your loaded mpi4py module using `module spider mpi4py/X.Y.Z` and verifying `python -c 'import mpi4py'` works, or ensuring the mpi4py module is loaded before activating your virtual environment."
  }
]