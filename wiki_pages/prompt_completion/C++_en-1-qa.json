[
  {
    "question": "What is C++ and who created it?",
    "answer": "C++ is a general-purpose, high-level, multi-paradigm programming language created by Bjarne Stroustrup at Bell Labs in 1979 by extending the C programming language."
  },
  {
    "question": "Which ISO C++ standards have been released?",
    "answer": "ISO C++ standards have been released corresponding to the years 1998, 2003, 2011, 2014, 2017, and 2020, commonly referred to as C++98, C++03, C++11, C++14, C++17, and C++20."
  },
  {
    "question": "What is the release cycle for new ISO C++ standards?",
    "answer": "The ISO C++ committee is currently releasing its standards on a three-year cycle; for example, after C++20, the next standard will be in 2023."
  },
  {
    "question": "Where can I find a definitive online reference for C++?",
    "answer": "A definitive, up-to-date, free online wiki reference for C++ (and its C Standard Library subset) is cppreference.com."
  },
  {
    "question": "Is C++ the same language as C?",
    "answer": "No, the C language is a distinct language from the C++ language, even though a lot of C code can be used in C++."
  },
  {
    "question": "What should you do if you are compiling C code as C++ code and need help?",
    "answer": "If you are compiling your C code as C++ code, you should refer to it as C++ code when asking for help."
  },
  {
    "question": "What was the situation with concurrency and memory models in ISO C++ standards prior to 2011?",
    "answer": "Prior to 2011, ISO C++ standards had no definitions of concurrency and memory models, meaning there were no guarantees concerning the ordering of memory reads and writes under concurrency in pre-C++11 compiled code."
  },
  {
    "question": "Why is it preferable to compile concurrent C++ code as C++11 or newer?",
    "answer": "It is preferable because pre-C++11 compiled code had no guarantees concerning the ordering of memory reads and writes under concurrency, which is likely undefined behavior. C++11 and newer standards provide well-defined concurrency and memory models."
  },
  {
    "question": "What are the benefits of using newer C++ compilers and standards?",
    "answer": "Newer compilers and standards allow full advantage of optimizations from features like `constexpr`, and provide updates to existing definitions that improve code correctness and/or optimizations."
  },
  {
    "question": "How do compiler implementations of C++ language features vary?",
    "answer": "Various compilers implement language features differently, and compiler releases sometimes only partially implement a specific ISO C++ standard."
  },
  {
    "question": "Where can I find information about compiler support for specific C++ language features?",
    "answer": "There is a wiki page at cppreference.com covering virtually all major C++ compilers and listing the earlier compiler versions implementing specific language features, along with links to compiler websites."
  },
  {
    "question": "Which C++ Standard Library implementation is typically used by C++ compilers under Linux?",
    "answer": "Many C++ compilers under Linux typically use libstdc++, which is distributed with GCC, rather than providing their own implementation."
  },
  {
    "question": "Why must C++ compilers other than GCC on Compute Canada systems be configured by administrators to use a specific version of libstdc++?",
    "answer": "This is necessary because several versions of GCC (and therefore libstdc++) are typically installed on a system, and improper configuration can lead to issues."
  },
  {
    "question": "What is a recommended practice to avoid issues with administrator-installed libraries?",
    "answer": "Users should never hard-code paths to administrator-installed libraries in order to compile software."
  },
  {
    "question": "Where can I find details on Standard Library components supported in libstdc++?",
    "answer": "The GCC documentation has a section that details which Standard Library components are supported in libstdc++."
  },
  {
    "question": "What is recommended for those new to C++ or needing an update?",
    "answer": "Start by checking out the ISO C++ advocacy site's 'Get Started' page, especially its recommended books."
  },
  {
    "question": "What is the specific meaning of the `volatile` keyword in C and C++?",
    "answer": "The `volatile` keyword in C and C++ has very specific meanings, for instance, to tell the compiler not to optimize away load/store side-effects from/to a variable in rare HPC instances."
  },
  {
    "question": "Is `volatile` commonly used in C/C++ code?",
    "answer": "No, needing to use `volatile` in C/C++ code is a rare event."
  },
  {
    "question": "Should `volatile` be used for synchronization in C/C++?",
    "answer": "No, `volatile` should never be used for synchronization; instead, C11/C++11 atomic operations and locks should be used."
  },
  {
    "question": "How does `volatile` in C/C++ compare to `volatile` in other languages like Java?",
    "answer": "`volatile` in other programming languages, such as Java, is often different than in C/C++; the latter would typically be implemented in C/C++ using synchronization constructs."
  },
  {
    "question": "What is a potential issue with the GCC compiler's -O3 option?",
    "answer": "The GCC compiler's -O3 option includes possibly unsafe optimizations for some types of code, such as code relying on aliasing."
  },
  {
    "question": "What is the recommended optimization option for GCC if you are unsure about -O3?",
    "answer": "If unsure, it is recommended to compile and optimize code using the -O2 option instead of -O3."
  },
  {
    "question": "What major change occurred with the transition from GCC version 4.9 to version 5.1?",
    "answer": "The transition introduced a major change to GCC's Application Binary Interface (ABI)."
  },
  {
    "question": "How can ABI issues be avoided when linking with previously compiled binaries if compiler versions change?",
    "answer": "If all source code, including dependent libraries, is recompiled using the same version of the compiler, there will be no issues. Alternatively, recompile older binaries from source with the newer compiler."
  },
  {
    "question": "What is a workaround for linking C++ code with legacy libraries built with an older GCC ABI?",
    "answer": "You can use GCC's Dual ABI feature by passing `-D_GLIBCXX_USE_CXX11_ABI=0` to GCC (v5.1 or higher) to use the old ABI for proper linking."
  },
  {
    "question": "What is the general assumption about the C++ ABI with major compiler releases?",
    "answer": "One should assume each major compiler release might break the C++ ABI enough that older binaries will have trouble linking C++ code."
  },
  {
    "question": "What options are recommended for Intel C/C++ compilers to ensure ANSI/ISO/IEEE standards-compliant floating-point support?",
    "answer": "Users are recommended to use one of two options: `-fp-model precise` or `-fp-model source`."
  },
  {
    "question": "What is a potential issue with Intel C/C++ compilers regarding floating-point operations?",
    "answer": "Intel C/C++ compilers may default to using possibly unsafe optimizations for floating-point operations."
  }
]