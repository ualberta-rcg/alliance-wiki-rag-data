[
  {
    "question": "Que se passe-t-il si aucune biblioth\u00e8que de pilote NVIDIA n'est trouv\u00e9e dans `/usr/lib64/nvidia` ?",
    "answer": "Si aucune biblioth\u00e8que n'est trouv\u00e9e dans `/usr/lib64/nvidia`, il est suppos\u00e9 que les versions du pilote sont suffisantes pour CUDA 10.2, assurant la compatibilit\u00e9 avec les versions ant\u00e9rieures puisque cette fonctionnalit\u00e9 a \u00e9t\u00e9 rendue disponible \u00e0 partir de CUDA 11.0."
  },
  {
    "question": "Comment peut-on cacher toutes les versions de CUDA en utilisant une variable d'environnement ?",
    "answer": "Il faut d\u00e9finir la variable d'environnement `RSNT_CUDA_DRIVER_VERSION` \u00e0 `0.0` (par exemple, `export RSNT_CUDA_DRIVER_VERSION=0.0`)."
  },
  {
    "question": "Quelle est la principale restriction pour l'utilisation de la variable d'environnement `RSNT_LOCAL_MODULEPATHS` ?",
    "answer": "Cette variable doit \u00eatre utilis\u00e9e uniquement avec des arbres de modules hi\u00e9rarchiques qui sont install\u00e9s via EasyBuild, pour que leur structure soit comme celle des modules centraux."
  },
  {
    "question": "Comment un arbre de modules local plat peut-il avoir une priorit\u00e9 plus \u00e9lev\u00e9e que l'arborescence centrale ?",
    "answer": "Pour ajouter un chemin local \u00e0 un arbre plat avec une priorit\u00e9 plus \u00e9lev\u00e9e, placez la commande `module use --priority 1 /path/to/your/flat/module/tree` apr\u00e8s l'appel du script."
  },
  {
    "question": "Comment un arbre de modules local plat peut-il avoir une priorit\u00e9 plus basse que l'arborescence centrale ?",
    "answer": "Pour que l'arborescence centrale soit prioritaire sur un arbre de modules local plat, utilisez `module use --priority -1 /path/to/your/flat/module/tree`."
  },
  {
    "question": "Quel est le but de la variable `RSNT_LOCAL_MODULEPATHS` ?",
    "answer": "Cette variable identifie les endroits o\u00f9 se trouvent les arbres de modules locaux et les int\u00e8gre \u00e0 l'arborescence centrale des modules."
  },
  {
    "question": "Comment configurer `RSNT_LOCAL_MODULEPATHS` et installer une recette logicielle en utilisant EasyBuild ?",
    "answer": "D'abord, d\u00e9finissez la variable `export RSNT_LOCAL_MODULEPATHS=/opt/software/easybuild/modules`, puis installez votre recette EasyBuild avec `eb --installpath /opt/software/easybuild <votre recette>.eb`."
  },
  {
    "question": "Quel impact a l'utilisation de `RSNT_LOCAL_MODULEPATHS` sur la nomenclature des modules d'une recette EasyBuild locale ?",
    "answer": "La nomenclature de modules du syst\u00e8me sera employ\u00e9e pour installer localement votre recette, et elle sera utilis\u00e9e dans la hi\u00e9rarchie des modules. Par exemple, une recette utilisant la cha\u00eene de compilation `iompi,2018.3` sera disponible apr\u00e8s que les modules `intel/2018.3` et `openmpi/3.1.2` auront \u00e9t\u00e9 charg\u00e9s."
  },
  {
    "question": "Quelle est la fonction de la variable d'environnement `LMOD_SYSTEM_DEFAULT_MODULES` ?",
    "answer": "Cette variable identifie les modules \u00e0 charger par d\u00e9faut."
  },
  {
    "question": "Quels modules sont charg\u00e9s par d\u00e9faut si `LMOD_SYSTEM_DEFAULT_MODULES` n'est pas d\u00e9finie ?",
    "answer": "Si elle n'est pas d\u00e9finie, l'environnement charge par d\u00e9faut le module `StdEnv` qui \u00e0 son tour charge par d\u00e9faut une version du compilateur Intel ainsi qu'une version OpenMPI."
  },
  {
    "question": "Comment les utilisateurs peuvent-ils d\u00e9finir leurs propres versions de modules par d\u00e9faut et leurs alias en utilisant Lmod ?",
    "answer": "Les utilisateurs peuvent d\u00e9finir leur propre fichier `modulerc` et l'ajouter \u00e0 la variable `MODULERCFILE`, ce qui aura pr\u00e9s\u00e9ance sur ce qui est d\u00e9fini dans l'environnement."
  },
  {
    "question": "Quel chemin de fichier est automatiquement ajout\u00e9 \u00e0 `MODULEPATH` s'il existe, permettant l'utilisation de modules locaux ?",
    "answer": "Le chemin `/opt/software/modulefiles` est automatiquement ajout\u00e9 au `MODULEPATH` par d\u00e9faut s'il existe."
  },
  {
    "question": "Quel chemin dans le r\u00e9pertoire personnel est automatiquement ajout\u00e9 \u00e0 `MODULEPATH` s'il existe ?",
    "answer": "Le chemin `$HOME/modulefiles` est automatiquement ajout\u00e9 au `MODULEPATH` par d\u00e9faut s'il existe."
  },
  {
    "question": "Quels chemins binaires sont automatiquement ajout\u00e9s au `PATH` par d\u00e9faut du syst\u00e8me ?",
    "answer": "Les chemins `/opt/software/slurm/bin`, `/opt/software/bin` et `/opt/slurm/bin` sont automatiquement ajout\u00e9s au `PATH` par d\u00e9faut."
  },
  {
    "question": "Depuis quand est-il possible d'installer des modules additionnels sur une grappe de calcul qui seront reconnus par la hi\u00e9rarchie centrale ?",
    "answer": "Il est possible d'installer des modules additionnels reconnus par la hi\u00e9rarchie centrale depuis juin 2020."
  },
  {
    "question": "Quelles sont les \u00e9tapes pour installer localement des modules additionnels sur une grappe de calcul en utilisant EasyBuild ?",
    "answer": "1. Identifiez et assurez-vous que le dossier d'installation existe (par exemple `/opt/software/easybuild`). 2. Exportez la variable d'environnement `RSNT_LOCAL_MODULEPATHS` (par exemple `export RSNT_LOCAL_MODULEPATHS=/opt/software/easybuild/modules`). 3. Installez les paquets logiciels avec EasyBuild : `eb --installpath /opt/software/easybuild <une recette easyconfig>`."
  }
]