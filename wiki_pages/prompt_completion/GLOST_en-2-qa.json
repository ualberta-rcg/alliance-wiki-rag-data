[
  {
    "question": "How do you execute GLOST with a list of tasks?",
    "answer": "You can execute GLOST using `srun glost_launch list_glost_example.txt`, where `list_glost_example.txt` is the argument specifying the tasks."
  },
  {
    "question": "What is the function of the `list_glost_tasks.txt` file in a GLOST setup?",
    "answer": "The `list_glost_tasks.txt` file serves as an argument for the `glost_launch` wrapper, containing the commands for the serial jobs."
  },
  {
    "question": "Do I need to adapt the provided example list of jobs and script for my workflow?",
    "answer": "Yes, both the list of jobs and the script should be adapted to your specific workflow."
  },
  {
    "question": "How can GLOST run multiple serial jobs in a single directory without output files overlapping?",
    "answer": "To prevent output overlap when running jobs in one directory, ensure that different jobs do not use the same temporary or output files, which can be achieved by adding arguments to differentiate them."
  },
  {
    "question": "How are multiple commands within a single job line in GLOST separated?",
    "answer": "Multiple commands within a single job line in GLOST should be separated by `&&`."
  },
  {
    "question": "What are the typical commands used in an example GLOST job line for running tasks in one directory?",
    "answer": "A typical GLOST job line might include fixing a variable like `nargument`, running a program (e.g., `sleep 360`), and executing additional commands such as `echo ${nargument}.hostname > log_${nargument}.txt`."
  },
  {
    "question": "What should the `sleep 360` command be replaced with in a practical GLOST application?",
    "answer": "The `sleep 360` command should be replaced by the actual command line required to run your application."
  },
  {
    "question": "How does GLOST distribute tasks among cores when running jobs in one directory?",
    "answer": "GLOST uses a cyclic distribution, assigning the first lines from the list of jobs to available processors. As processors complete tasks, GLOST assigns them subsequent jobs until the list is exhausted or the job runs out of time."
  },
  {
    "question": "Why would someone choose to run GLOST jobs in separate directories?",
    "answer": "Running GLOST jobs in separate directories is useful to prevent program crashes or result overlaps when a program uses files (temporary, input, or output) with identical names across different jobs."
  },
  {
    "question": "What steps are necessary before running GLOST jobs in dedicated directories?",
    "answer": "Before running GLOST jobs in dedicated directories, you must create the input files and a specific directory for each job, either manually or by including these steps within the line commands."
  },
  {
    "question": "How do you restart a GLOST job if the wall time was underestimated?",
    "answer": "To restart an underestimated GLOST job, identify the completed tasks, remove their corresponding lines from the list, or create a new list with only the remaining jobs, then resubmit your script with this new list as an argument for `glost_launch`."
  },
  {
    "question": "How can advanced users find more GLOST examples?",
    "answer": "After loading the GLOST module, advanced users can copy examples to their local directory by running the command `cp -r $EBROOTGLOST/examples Glost_Examples`."
  },
  {
    "question": "Where are the copied GLOST examples stored?",
    "answer": "The copied GLOST examples will be saved under the directory named `Glost_Examples`."
  }
]