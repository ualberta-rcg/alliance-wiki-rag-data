[
  {
    "question": "Quels sont les objectifs d'apprentissage concernant la gestion des donn\u00e9es en OpenACC?",
    "answer": "Les objectifs incluent la compr\u00e9hension des principes de localit\u00e9 et de mouvement des donn\u00e9es, la diff\u00e9rence entre donn\u00e9es structur\u00e9es et non structur\u00e9es, savoir faire un transfert explicite, et savoir compiler et ex\u00e9cuter du code OpenACC avec des directives de mouvement."
  },
  {
    "question": "Qu'est-ce qui a \u00e9t\u00e9 utilis\u00e9 pour simplifier les premi\u00e8res \u00e9tapes d'acc\u00e9l\u00e9ration du code?",
    "answer": "CUDA Unified Memory a \u00e9t\u00e9 utilis\u00e9 pour simplifier les premi\u00e8res \u00e9tapes d'acc\u00e9l\u00e9ration du code."
  },
  {
    "question": "Pourquoi le code utilisant CUDA Unified Memory n'est-il pas portable?",
    "answer": "Le code utilisant CUDA Unified Memory n'est pas portable car il est sp\u00e9cifique \u00e0 PGI avec l'indicateur \u2013ta=tesla:managed et \u00e0 NVIDIA (CUDA Unified Memory)."
  },
  {
    "question": "Quel est l'avantage de la gestion explicite des donn\u00e9es?",
    "answer": "La gestion explicite des donn\u00e9es rend le code portable et peut am\u00e9liorer la performance."
  },
  {
    "question": "\u00c0 quoi sert la directive `data` en OpenACC?",
    "answer": "La directive `data` d\u00e9limite la zone du code o\u00f9 les tableaux GPU restent sur le GPU et sont partag\u00e9s par tous les noyaux de la zone."
  },
  {
    "question": "Comment d\u00e9finit-on une zone de donn\u00e9es structur\u00e9es en C++ avec OpenACC?",
    "answer": "Une zone de donn\u00e9es structur\u00e9es en C++ est d\u00e9finie en utilisant `#pragma acc data { ... }`."
  },
  {
    "question": "Comment d\u00e9finit-on une zone de donn\u00e9es structur\u00e9es en Fortran avec OpenACC?",
    "answer": "Une zone de donn\u00e9es structur\u00e9es en Fortran est d\u00e9finie en utilisant `!$acc data ... !$acc end data`."
  },
  {
    "question": "Que signifie la localit\u00e9 des donn\u00e9es dans le contexte des zones de donn\u00e9es OpenACC?",
    "answer": "La localit\u00e9 des donn\u00e9es signifie que les tableaux \u00e0 l'int\u00e9rieur de la zone de donn\u00e9es restent sur le GPU jusqu'\u00e0 la fin de cette zone."
  },
  {
    "question": "Quand utilise-t-on des directives de donn\u00e9es non structur\u00e9es?",
    "answer": "On utilise des directives de donn\u00e9es non structur\u00e9es lorsque la d\u00e9limitation d'une zone ne permet pas l'utilisation de zones de donn\u00e9es normales, par exemple avec des constructeurs ou des destructeurs."
  },
  {
    "question": "Quelles sont les directives principales pour la gestion des donn\u00e9es non structur\u00e9es?",
    "answer": "Les directives principales sont `enter data` pour le d\u00e9but de la dur\u00e9e de vie des donn\u00e9es non structur\u00e9es et `exit data` pour la fin."
  },
  {
    "question": "Quelles clauses sont utilis\u00e9es avec la directive `enter data`?",
    "answer": "Les clauses utilis\u00e9es avec `enter data` sont `copyin(list)` et `create(list)`."
  },
  {
    "question": "Quelles clauses sont utilis\u00e9es avec la directive `exit data`?",
    "answer": "Les clauses utilis\u00e9es avec `exit data` sont `copyout(list)` et `delete(list)`."
  },
  {
    "question": "Quel est l'avantage des clauses de donn\u00e9es non structur\u00e9es?",
    "answer": "Les clauses de donn\u00e9es non structur\u00e9es permettent l'utilisation d'OpenACC dans les classes C++ et peuvent \u00eatre utilis\u00e9es quand les donn\u00e9es sont allou\u00e9es/initialis\u00e9es et lib\u00e9r\u00e9es dans des portions de code diff\u00e9rentes."
  },
  {
    "question": "\u00c0 quoi sert la clause `copyin(list)` de la directive `data`?",
    "answer": "La clause `copyin(list)` sert \u00e0 allouer de la m\u00e9moire du GPU et \u00e0 copier des donn\u00e9es de la m\u00e9moire de d\u00e9part vers le GPU, \u00e0 l'entr\u00e9e de la zone."
  },
  {
    "question": "\u00c0 quoi sert la clause `copyout(list)` de la directive `data`?",
    "answer": "La clause `copyout(list)` sert \u00e0 allouer de la m\u00e9moire du GPU et \u00e0 copier des donn\u00e9es vers la m\u00e9moire de d\u00e9part, \u00e0 la sortie de la zone."
  },
  {
    "question": "\u00c0 quoi sert la clause `copy(list)` de la directive `data`?",
    "answer": "La clause `copy(list)` sert \u00e0 allouer de la m\u00e9moire du GPU et \u00e0 copier des donn\u00e9es de la m\u00e9moire de d\u00e9part vers le GPU \u00e0 l'entr\u00e9e de la zone, et \u00e0 copier des donn\u00e9es vers la m\u00e9moire de d\u00e9part \u00e0 la sortie de la zone (pour les donn\u00e9es structur\u00e9es seulement)."
  },
  {
    "question": "\u00c0 quoi sert la clause `create(list)` de la directive `data`?",
    "answer": "La clause `create(list)` sert \u00e0 allouer de la m\u00e9moire du GPU, sans copier de donn\u00e9es."
  },
  {
    "question": "\u00c0 quoi sert la clause `delete(list)` de la directive `data`?",
    "answer": "La clause `delete(list)` sert \u00e0 d\u00e9sallouer de la m\u00e9moire du GPU, sans copier (pour les donn\u00e9es non structur\u00e9es seulement)."
  },
  {
    "question": "\u00c0 quoi sert la clause `present(list)` de la directive `data`?",
    "answer": "La clause `present(list)` indique que le GPU contient d\u00e9j\u00e0 des donn\u00e9es en provenance d'une autre r\u00e9gion."
  },
  {
    "question": "Pourquoi est-il n\u00e9cessaire de sp\u00e9cifier la taille et le format d'un tableau dans OpenACC?",
    "answer": "Il est n\u00e9cessaire de sp\u00e9cifier la taille et le format d'un tableau car le compilateur ne peut pas toujours les d\u00e9terminer."
  },
  {
    "question": "Comment se fait la copie d'une matrice dans la m\u00e9moire avec le mouvement explicite des donn\u00e9es?",
    "answer": "La copie se fait en deux \u00e9tapes : copier la structure de la matrice, puis copier les membres de la matrice."
  },
  {
    "question": "Comment lib\u00e8re-t-on la m\u00e9moire d'une matrice avec le mouvement explicite des donn\u00e9es?",
    "answer": "Pour lib\u00e9rer la m\u00e9moire, il faut d'abord supprimer les membres de la matrice, puis supprimer sa structure, et enfin \u00e9noncer la commande `free`."
  },
  {
    "question": "Quel est l'objectif de la clause `present` dans OpenACC?",
    "answer": "La clause `present` sert \u00e0 indiquer au compilateur que les donn\u00e9es se trouvent d\u00e9j\u00e0 en m\u00e9moire, ce qui est crucial pour une gestion de haut niveau."
  },
  {
    "question": "Quels sont les \u00e9l\u00e9ments critiques pour assurer une bonne performance en OpenACC?",
    "answer": "Les \u00e9l\u00e9ments critiques pour assurer une bonne performance sont une gestion de haut niveau et l'utilisation de la clause `present`."
  },
  {
    "question": "Comment compiler un nouveau build sans m\u00e9moire autog\u00e9r\u00e9e en OpenACC?",
    "answer": "Pour compiler sans m\u00e9moire autog\u00e9r\u00e9e, il faut remplacer l'indicateur `-ta=tesla:managed` par `-ta-tesla` dans le Makefile."
  },
  {
    "question": "\u00c0 quoi sert la directive `update`?",
    "answer": "La directive `update` permet d'actualiser un tableau ou une partie d'un tableau, en copiant des donn\u00e9es entre le GPU et le CPU."
  },
  {
    "question": "Comment copier des donn\u00e9es du GPU vers le CPU avec la directive `update`?",
    "answer": "Pour copier du GPU vers le CPU, on utilise `!$acc update self(variable)`."
  },
  {
    "question": "Comment copier des donn\u00e9es du CPU vers le GPU avec la directive `update`?",
    "answer": "Pour copier du CPU vers le GPU, on utilise `!$acc update device(variable)`."
  }
]