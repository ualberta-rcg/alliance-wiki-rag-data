[
  {
    "question": "What kind of programming language is C?",
    "answer": "C is a general-purpose, high-level, imperative programming language."
  },
  {
    "question": "Who created the C programming language and when?",
    "answer": "C was created by Dennis Ritchie between 1969 and 1973 at Bell Labs."
  },
  {
    "question": "What are the common ISO standards for C and their corresponding years?",
    "answer": "C is represented by ISO standards corresponding to the years 1989/1990, 1999, and 2011, usually referred to as C90 (or C89), C99, and C11."
  },
  {
    "question": "What new features did the C99 standard introduce?",
    "answer": "C99 added language and Standard Library features, and `int` is no longer implicitly assumed."
  },
  {
    "question": "What major additions did the C11 standard bring to the C language?",
    "answer": "C11 was a major release adding memory model and concurrency support, including threads, atomics, and compare-and-swap."
  },
  {
    "question": "Where can one find links to drafts of the ISO C standard documents?",
    "answer": "Links to the last draft before each ISO C standard release can be obtained from the reference sections of the Wikipedia pages mentioned."
  },
  {
    "question": "Where can the official ISO C standard document be purchased?",
    "answer": "The official document may be purchased from the Standards Council of Canada."
  },
  {
    "question": "What was the situation regarding concurrency and memory models in the ISO C standard before 2011?",
    "answer": "Prior to 2011, the ISO C standard had no definitions of concurrency and memory models."
  },
  {
    "question": "What are the implications of compiling concurrent C code using pre-C11 standards?",
    "answer": "In pre-C11 compiled code, there are no guarantees concerning the ordering of memory reads and writes under concurrency, which is likely undefined behaviour."
  },
  {
    "question": "Why is it recommended to compile concurrent C code as C11 or newer?",
    "answer": "It is preferable because pre-C11 compiled code offers no guarantees for the ordering of memory reads and writes under concurrency, leading to likely undefined behaviour."
  },
  {
    "question": "What is the typical use case for the `volatile` keyword in C and C++?",
    "answer": "Actually needing to use `volatile` in C/C++ code is a rare event, typically limited to certain kinds of low-level code."
  },
  {
    "question": "How does the `volatile` keyword in Java compare to its meaning in C?",
    "answer": "Java's `volatile` has a totally different meaning from C's `volatile`; specifically, Java's `volatile` in C corresponds to using `atomic_*` (e.g., `atomic_int`)."
  },
  {
    "question": "What potential issue does GCC's -O3 optimization option present?",
    "answer": "The GCC compiler's -O3 option includes possibly unsafe optimizations for some types of code, such as code relying on aliasing."
  },
  {
    "question": "Which GCC optimization option is recommended if a user is unsure about -O3?",
    "answer": "If unsure, it is recommended to compile and optimize code using the -O2 option instead of -O3."
  },
  {
    "question": "What kind of unsafe optimizations might Intel C/C++ compilers default to?",
    "answer": "Intel C/C++ compilers may default to using possibly unsafe optimizations for floating-point operations."
  },
  {
    "question": "What options are recommended for Intel compilers to achieve ANSI/ISO/IEEE standards-compliant floating-point support?",
    "answer": "Users are recommended to use one of two options: `-fp-model precise` or `-fp-model source` for ANSI/ISO/IEEE standards-compliant floating-point support."
  }
]