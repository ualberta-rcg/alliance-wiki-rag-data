[
  {
    "question": "Can Valgrind detect memory errors even if a program doesn't crash with a segmentation fault?",
    "answer": "Yes, Valgrind can detect errors even if the program doesn't terminate with a segmentation fault or other errors. Minor memory access problems, like reading beyond array limits, often go unnoticed by the system but are detected by Valgrind."
  },
  {
    "question": "What does a typical Valgrind error message for a memory leak look like?",
    "answer": "A typical Valgrind message for a memory leak, produced at the end of program execution, would resemble: '==2116== 100 bytes in 1 blocks are definitely lost in loss record 1 of 1 ==2116== at 0x1B900DD0: malloc (vg_replace_malloc.c:131) ==2116== by 0x804840F: main (in /home/cprogram/example1)'."
  },
  {
    "question": "How does Valgrind report invalid pointer usage or out-of-bounds memory access?",
    "answer": "If you attempt to write to an unallocated pointer or outside allocated memory boundaries, Valgrind will display an error message similar to: '==9814== Invalid write of size 1 ==9814== at 0x804841E: main (example2.c:6) ==9814== Address 0x1BA3607A is 0 bytes after a block of size 10 alloc'd ==9814== at 0x1B900DD0: malloc (vg_replace_malloc.c:131) ==9814== by 0x804840F: main (example2.c:5)'."
  },
  {
    "question": "What message does Valgrind show if a program uses an uninitialized variable?",
    "answer": "For the use of an uninitialized variable, Valgrind will produce an error message like: '==17943== Conditional jump or move depends on uninitialised value(s) ==17943== at 0x804840A: main (example3.c:6)'."
  }
]