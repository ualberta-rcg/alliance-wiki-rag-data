[
  {
    "question": "What are the learning objectives of this document?",
    "answer": "The learning objectives are to understand the difference between a CPU and an accelerator, the difference between speed and throughput, and the steps to take to port an existing code to an accelerator."
  },
  {
    "question": "What tasks were Central Processing Units (CPUs) historically optimized for?",
    "answer": "Historically, CPUs were optimized for sequential tasks, completing only one compute operation during a given clock cycle."
  },
  {
    "question": "When did high-end CPU clock frequencies reach a plateau and at what approximate speed?",
    "answer": "High-end CPU clock frequencies reached a plateau at around 4 GHz around 2005."
  },
  {
    "question": "What change did manufacturers implement in CPUs after 2005?",
    "answer": "After 2005, manufacturers started adding multiple computation cores within a single chipset, opening wide the era of parallel computing."
  },
  {
    "question": "Why do sequential tasks still run fastest on CPUs as of 2022?",
    "answer": "Sequential tasks still run fastest on CPUs because they have direct access to large main computer memory and their very fast clock speed allows them to run a small number of tasks very quickly."
  },
  {
    "question": "What are the main weaknesses of CPUs?",
    "answer": "CPUs have relatively low memory bandwidth, costly cache misses, and are rather power-hungry compared to accelerators."
  },
  {
    "question": "What are typical accelerators, as described in the document?",
    "answer": "Typical accelerators include GPUs and coprocessors."
  },
  {
    "question": "What are accelerators optimized for?",
    "answer": "Accelerators are optimized for parallel computing."
  },
  {
    "question": "How are typical accelerators structured?",
    "answer": "Typical accelerators are highly parallel chipsets made out of hundreds or thousands of relatively simple and low-frequency compute cores."
  },
  {
    "question": "What advantages do high-end GPUs offer compared to high-end CPUs?",
    "answer": "High-end GPUs present significantly more compute resources than high-end CPUs, provide much higher throughput, and much better performance per watt. They also have a high bandwidth to access their own device memory."
  },
  {
    "question": "What are the weaknesses of accelerators?",
    "answer": "Accelerators embed a relatively low amount of memory and have low per-thread performance."
  },
  {
    "question": "What is the characteristic of a 'high speed' device?",
    "answer": "A high speed device will accomplish a single task within a very short amount of time."
  },
  {
    "question": "When should you use a high-speed device?",
    "answer": "You should use a high-speed device for a single sequential computation, such such as the resolution of a one-dimensional differential equation."
  },
  {
    "question": "What is a real-life analogy for a high-speed device?",
    "answer": "A real-life analogy for a high-speed device is a racing motorcycle or a racing car, which brings a single passenger from point A to point B very quickly."
  },
  {
    "question": "What defines a 'high throughput' device?",
    "answer": "A high throughput device will accomplish much more work, but in a longer amount of time."
  },
  {
    "question": "When is a high-throughput device suitable?",
    "answer": "A high-throughput device is suitable when trying to solve a highly parallel problem, such as matrix operations, Fourier transforms, or multidimensional differential equations."
  },
  {
    "question": "What is a real-life analogy for a high-throughput device?",
    "answer": "A real-life analogy for a high-throughput device is a train or a bus, which brings a lot of passengers from point A to point B, but in a longer time."
  },
  {
    "question": "How can porting code to accelerators be viewed in a broader context?",
    "answer": "Porting a code to accelerators can be seen as a phase of an optimization process."
  },
  {
    "question": "What are the typical steps in an optimization process?",
    "answer": "The typical steps in an optimization process are: Profile the code, Identify bottlenecks, Optimize the most significant bottleneck, Validate the resulting code, and then Start again from step 1."
  },
  {
    "question": "What are the specific steps involved in porting a code to accelerators?",
    "answer": "The specific steps for porting a code to accelerators are: Profile the code, Identify parallelism within the bottlenecks, Port the code (which includes Express parallelism to the compiler, Express data movement, and Optimize loops), Validate the resulting code, and Start again from step 1."
  },
  {
    "question": "In OpenACC, what does 'express parallelism to the compiler' entail?",
    "answer": "In OpenACC, 'express parallelism to the compiler' means the programmer tells the compiler that a given portion of the code can be parallelized by adding a few directives, letting the compiler figure out exactly how to do it."
  },
  {
    "question": "What is the purpose of the 'express data movement' phase when porting code to accelerators?",
    "answer": "The 'express data movement' phase addresses unnecessary data movement that might not be handled by the compiler, even the best ones."
  },
  {
    "question": "Why is the 'optimize loops' step important in porting code to accelerators?",
    "answer": "The 'optimize loops' step is important because the programmer may possess information not available to the compiler, which would allow them to achieve better performance by tuning the loops."
  }
]