[
  {
    "question": "How do you compile the `phello2.c` program?",
    "answer": "You can compile `phello2.c` using the command `mpicc -Wall phello2.c -o phello2`."
  },
  {
    "question": "How do you execute the compiled `phello2` program with 4 processes?",
    "answer": "To execute the `phello2` program with 4 processes, use the command `mpirun -np 4 ./phello2`."
  },
  {
    "question": "What is an example output when running `phello2` with 4 processes?",
    "answer": "An example output when running `phello2` with 4 processes is:\n`[P_0] process 3 said: \"Hello, world! from process 3 of 4\"]\n[P_1] process 0 said: \"Hello, world! from process 0 of 4\"]\n[P_2] process 1 said: \"Hello, world! from process 1 of 4\"]\n[P_3] process 2 said: \"Hello, world! from process 2 of 4\"]`"
  },
  {
    "question": "Are `MPI_Send` and `MPI_Recv` blocking calls according to the MPI standard?",
    "answer": "Yes, `MPI_Send` and `MPI_Recv` are blocking calls in the MPI standard."
  },
  {
    "question": "When does `MPI_Send` return according to the MPI standard?",
    "answer": "`MPI_Send` does not return until it is safe for the calling module to modify the content of the buffer."
  },
  {
    "question": "When does `MPI_Recv` return according to the MPI standard?",
    "answer": "`MPI_Recv` does not return until all the content of the message is located in the buffer."
  },
  {
    "question": "Why did the `phello2` example not lead to a deadlock despite all processes calling `MPI_Send` first?",
    "answer": "The `phello2` example did not lead to a deadlock because most MPI implementations put data into a temporary buffer when `MPI_Send` is called and return without waiting for the message to be delivered. This allows the program to proceed without blocking indefinitely."
  },
  {
    "question": "Why is a program like `phello2` considered at risk of a deadlock?",
    "answer": "A program like `phello2` is considered at risk of a deadlock because its correct functioning depends on the MPI library providing a buffer, which is not required by the MPI standard. If a buffer is not used or is saturated, `MPI_Send` could block, leading to a deadlock."
  },
  {
    "question": "What is an example of a deadlock in MPI communication?",
    "answer": "An example of a deadlock is when `rank == 0` calls `MPI_Recv(from 1)` and `rank == 1` calls `MPI_Recv(from 0)`, causing both processes to wait indefinitely for a message that will not be sent because the other process is also waiting to receive."
  },
  {
    "question": "What constitutes an \"at-risk situation\" in MPI communication?",
    "answer": "An \"at-risk situation\" is when `rank == 0` calls `MPI_Send(to 1)` followed by `MPI_Recv(from 1)`, and `rank == 1` also calls `MPI_Send(to 0)` followed by `MPI_Recv(from 0)`. This might work if the MPI library buffers messages, but it will block if buffering is not available or if the message size exceeds buffer capacity."
  },
  {
    "question": "How can one create reliable MPI code to avoid deadlocks?",
    "answer": "One can create reliable MPI code by coupling send and receive operations without relying on a buffer. For example, `rank == 0` calls `MPI_Send(to 1)` then `MPI_Recv(from 1)`, while `rank == 1` calls `MPI_Recv(from 0)` then `MPI_Send(to 0)`. This ensures that a receive is always initiated before the corresponding send."
  },
  {
    "question": "What is a common strategy to ensure that MPI code is correct and avoids deadlocks?",
    "answer": "A common and convenient strategy to ensure correct and deadlock-free MPI code is to use odd-even pairing and proceed in two steps. This means that, for a communication pattern, odd-ranked processes execute sends followed by receives, while even-ranked processes execute receives followed by sends (or vice-versa), ensuring defined send-receive pairs."
  },
  {
    "question": "Does the odd-even pairing strategy pose a problem with an odd number of processes?",
    "answer": "No, an odd number of processes does not necessarily pose a problem for the odd-even pairing strategy. For example, in a ring communication, process 0 (even) sends to process 1 (odd), which starts with a receive, thus completing the transaction. Process 0 then receives from process N-1, and though there might be a slight delay, there is no risk of deadlock."
  }
]