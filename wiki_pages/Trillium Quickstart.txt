<languages /> 
<translate>
<!--T:122-->
__TOC__

= Overview = <!--T:123-->

<!--T:124-->
Trillium is a large parallel cluster built by Lenovo Canada and hosted by SciNet at the University of Toronto. It consists of three main components:

<!--T:125-->
1. CPU Subcluster

<!--T:126-->
* 235,008 cores provided by 1224 CPU compute nodes 
* Each CPU compute node has 192 cores from two 96-core AMD EPYC 9655 CPUs ("Zen 5" a.k.a. "Turin") at 2.6 GHz (base frequency)
* Each CPU compute node has 755 GiB / 810 GB of available memory
* The nodes are connected by a non-blocking (1:1) 400 Gb/s InfiniBand NDR interconnect
* This subcluster is designed for large-scale parallel workloads 

<!--T:127-->
2. GPU Subcluster
* 252 GPUs provided by 63 GPU compute nodes.
* Each GPU compute node has 4 NVIDIA H100 (SXM) GPUs with 80 GB of dedicated VRAM
* Each GPU compute node also has 96 cores from one 96-core AMD EPYC 9654 CPUs ("Zen 4" a.k.a. "Genoa") at 2.4 GHz (base frequency)
* The nodes are connected by a non-blocking (1:1) 800 Gb/s InfiniBand NDR interconnect, i.e. 200 Gb/s per GPU
* Has a dedicated login node (trig-login01) with 4 four NVIDIA H100 (SXM) GPUs.
* This subcluster is optimized for AI/ML and accelerated science workloads 

<!--T:128-->
3. Storage System
* Unified 29 PB VAST NVMe storage for all workloads
* All flash-based for consistent performance  
* Accessible as a standard shared parallel file system.

= Getting started on Trillium = <!--T:129-->

<!--T:130-->
You need an active [https://ccdb.alliancecan.ca CCDB] account from the [https://alliancecan.ca/en Digital Research Alliance of Canada].  With that, you can then request access to Trillium on the [https://ccdb.alliancecan.ca/me/access_systems Access Systems] page on the [https://ccdb.alliancecan.ca CCDB] site. After clicking the "I request access" button, it usually takes about an hour for your account to be actually created and available on Trillium.

<!--T:131-->
Please read this present document carefully.  The [[Frequently Asked Questions]] is also a useful resource.  If at any time you require assistance, or if something is unclear, please do not hesitate to [mailto:trillium@tech.alliancecan.ca contact us].

== Logging in == <!--T:132-->

<!--T:278-->
There are two ways to access Trillium:

<!--T:279-->
# Via your browser with Open OnDemand. This is recommended for users who are not familiar with Linux or the command line. Please see our [https://docs.scinet.utoronto.ca/index.php/Open_OnDemand_Quickstart quickstart guide] for more instructions on how to use Open OnDemand.
# Terminal access with ssh. Please read the following instructions.

<!--T:133-->
As with all SciNet and Alliance compute systems, access is done via [[SSH]] (secure shell). Furthermore, for Trillium specifically, authentication is only allowed via SSH keys that are uploaded to the [https://ccdb.alliancecan.ca CCDB]. [[SSH Keys | Please refer to this page]] on how to generate your SSH key pair, upload, and use SSH Keys.

<!--T:134-->
Trillium runs Rocky Linux 9.6, which is a type of Linux.  You will need to be familiar with the Linux shell to work on Trillium.  If you are not, it will be worth your time to review the [[Linux introduction]], to attend a [https://explora.alliancecan.ca/events?include_expired=true&keywords=Shell Linux Shell course], or to take some of our [[Self-paced courses]].
 
You can use [[SSH]] by opening a terminal window (e.g. [[Connecting with PuTTY ]] on Windows or [[Connecting with MobaXTerm]]), then SSH into the Trillium login nodes with your CCDB credentials.

<!--T:135-->
* Use this command to log into one of the login nodes of the CPU subcluster:
<pre>
$ ssh -i /PATH/TO/SSH_PRIVATE_KEY  MYALLIANCEUSERNAME@trillium.scinet.utoronto.ca
</pre>

<!--T:136-->
* To log into the login node for the GPU cluster, use this command
<pre>
$ ssh -i /PATH/TO/SSH_PRIVATE_KEY  MYALLIANCEUSERNAME@trillium-gpu.scinet.utoronto.ca
</pre>

<!--T:137-->
Here, <code>/PATH/TO/SSH_PRIVATE_KEY</code> is the path to your private SSH key and <code>MYALLIANCEUSERNAME</code> is your username on the CCDB.

<!--T:138-->
'''Note that:'''
* The first time you login, you should make sure you are actually accessing Trillium by checking if the [[SSH security improvements/en#Trillium|login node ssh host key fingerprint]] matches. 
* The Trillium login nodes are where you develop, edit, compile, prepare and submit jobs.
* The CPU login nodes and the GPU login node are not part of the compute nodes but they have the same architecture, operating system, and software stack as the CPU and GPU compute nodes, respectively.
* You can ssh from one login node to another using their internal hostnames <code>tri-login01, ..., tri-login06</code> and <code>trig-login01</code> (the latter is the GPU login node).
* If you add the option <code>-Y</code> you enable X11 forwarding, which allows graphical programs on Trillium to open windows on your local computer.
* To run on compute nodes, you must submit a batch job.

<!--T:139-->
'''On the login nodes, you may not:'''
* Run large memory jobs
* Run parallel training or highly multi-threaded processes
* Run long computations (keep them under a few minutes)
* Run resource-intensive tasks like I/O-heavy operations or simulation.

<!--T:140-->
If you cannot log in, be sure to first check the [https://status.alliancecan.ca System Status], ensure your [https://ccdb.alliancecan.ca CCDB] account is active and that your public key was uploaded (in openssh format) to CCDB, and check that you had requested access on the [https://ccdb.alliancecan.ca/me/access_systems Access Systems] page.

== Storage == <!--T:142-->

<!--T:143-->
Trillium features a unified high-performance storage system based on the VAST platform. It serves the following directories:

<!--T:144-->
* <code>home file system</code> – For personal files and configurations.
* <code>scratch file system</code> – High-speed, temporary personal storage for job data.
* <code>project file system</code> – Shared storage for project teams and collaborations.

<!--T:145-->
For your convenience, the location of the top level of your home and scratch directories on these file systems are available in the environment variables <code>$HOME</code> and <code>$SCRATCH</code>, while the variable <code>$PROJECT</code> points at your directory on /project.  

<!--T:146-->
You may be part of several projects. In that case, <code>$PROJECT</code> points at your last project in alphabetical order (often, that is the one associated with an allocation).  But you can find all the top level directories of  projects that you have access to in <code>$HOME/links/projects</code>, next to a link <code>$HOME/links/scratch</code> which points to <code>$SCRATCH</code>.  If you do not see the directory <code>$HOME/links</code> in your account, you can get it by running the command
<pre>
$ trisetup
</pre>
The content of the <code>$HOME/links/projects</code> will automatically update when you leave or join projects.

<!--T:147-->
On [[Using nearline storage|HPSS]], the nearline system to be attached to Trillium, there will also be an environment variable called <code>$ARCHIVE</code> to point at the location of your top directory there, if you have one.

<!--T:148-->
The table below summarized the available space and policiies for each location:

<!--T:149-->
{| class="wikitable"
! location
! quota
! expiration time
! backed up
! on login nodes
! on compute nodes
|-
| $HOME
| 100 GB per user
| none
| yes
| yes
| read-only
|-
| $SCRATCH
| 25 TB per user<sup>(1)</sup>
| TBD<sup>*</sup>
| no
| yes
| yes
|-
| $PROJECT
| determined by RAC allocation
1 TB per default group<sup>(2)</sup>
| none 
| yes
| yes
| read-only
|-
| $ARCHIVE
| determined by RAC allocation<sup>(2)</sup>
| none
| dual-copy
| no
| no
|}
<small><sup>(1)</sup>The SCRATCH policies are still subject to revision.</small>

<!--T:277-->
<small><sup>(2)</sup>There is no RAC mechanism to increase project ($PROJECT) and nearline ($ARCHIVE) quotas on Trillium.</small>

== Software == <!--T:150-->

<!--T:151-->
Trillium uses the [[Using modules|environment modules]] system to manage compilers, libraries, and other software packages. Modules dynamically modify your environment (e.g., <code>PATH</code>, <code>LD_LIBRARY_PATH</code>) so you can access different versions of software without conflicts.

<!--T:152-->
Commonly used module commands:

<!--T:153-->
* <code>module load <module-name></code> – Load the default version of a software package.
* <code>module load <module-name>/<module-version></code> – Load a specific version.
* <code>module purge</code> – Unload all currently loaded modules.
* <code>module avail</code> – List available modules that can be loaded.
* <code>module list</code> – Show currently loaded modules.
* <code>module spider</code> or <code>module spider <module-name></code> – Search for modules and their versions.

<!--T:154-->
Handy abbreviations are available:

<!--T:155-->
* <code>ml</code> – Equivalent to <code>module list</code>.
* <code>ml <module-name></code> – Equivalent to <code>module load <module-name></code>.

<!--T:156-->
When you have just logged in, only the <code>CCconfig</code>, <code>gentoo/2023</code> and <code>mii</code> modules are loaded, which provide basic OS-level functionality.  To get a standard set of compilers and libraries like on the other compute clusters in the Alliance, you load the <code>StdEnv/2023</code>.

== Tips for loading software == <!--T:157-->

<!--T:158-->
Properly managing your software environment is key to avoiding conflicts and ensuring reproducibility. Here are some best practices:

<!--T:159-->
* Avoid loading modules in your <code>.bashrc</code> file. Doing so can cause unexpected behavior, particularly in non-interactive environments like batch jobs or remote shells. 

<!--T:160-->
* Instead, load modules manually, from a separate script, or using module collections. This approach gives you more control and helps keep environments clean.

<!--T:161-->
* Load required modules inside your job script. This ensures that your job runs with the expected software environment, regardless of your interactive shell settings.

<!--T:162-->
* Be explicit about module versions. Short names like <code>gcc</code> will load the system default (e.g., <code>gcc/12.3</code>), which may change in the future. Specify full versions (e.g., <code>gcc/13.3</code>) for long-term reproducibility.

<!--T:163-->
* Resolve dependencies with <code>module spider</code>. Some modules depend on others. Use <code>module spider <module-name></code> to discover which modules are required and how to load them in the correct order. For more, see [[Utiliser des modules/en#Sub-command_spider |Sub-command spider]].

== Using commercial software == <!--T:164-->

<!--T:165-->
You may be able to use commercial software on Trillium, but there are a few important considerations:

<!--T:166-->
* Bring your own license. You can use commercial software on Trillium if you have a valid license. If the software requires a license server, you can connect to it securely using [[SSH tunnelling]].

<!--T:167-->
* We do not provide user-specific licenses. Due to the large and diverse user base, we cannot provide licenses for individual or specialized commercial packages.

<!--T:168-->
* Some widely useful commercial tools are available system-wide, such as compilers (Intel), math libraries (MKL), debuggers (DDT).

<!--T:169-->
* We're here to help. If you have a valid license and need help installing commercial software, feel free to contact us, we'll assist where possible.

= Testing and debugging = <!--T:170-->

<!--T:171-->
Before submitting your job to the cluster, it's important to test your code to ensure correctness and determine the resources it requires.

<!--T:172-->
* '''Lightweight tests''' can be run directly on the login nodes. As a rule of thumb, these should:
** Run in under a few minutes  
** Use no more than 1–2 GB of memory  
** Use only 1–4 CPU cores
** Use at most 1 GPU 

<!--T:173-->
* You can also run the parallel [[ARM_software|ARM DDT]] debugger on the login nodes after loading it with <code>module load ddt-cpu</code> or <code>module load ddt-gpu</code>

<!--T:174-->
* For tests that exceed login node limits or require dedicated resources, request an interactive debug job using the <code>debugjob</code> command on a login node:
<pre>
$ debugjob
</pre>
When run from a CPU login node, this command gives you an interactive shell on a CPU compute session for 1-hour. When running the debugjob command from the GPU login node, you get an interactive session with 1 GPU on a (shared) GPU compute node for two hours.  A few variations of this command that you can use to request more resources for an interactive session, are given in the next table. Note that the more resources you request, the shorter the allowed walltime is (this helps makes sure that interactive session almost always start right away).
{| class="wikitable"
!Command
!Subcluster
!Number of nodes
!Number of CPU cores
!Number of GPUs
!Memory
!Walltime limit
|-
|debugjob   ||CPU|| 1 ||192||0||  755GiB|| 60 minutes
|-
|debugjob 2 ||CPU|| 2 ||384||0||2x755GiB|| 30 minutes
|-
|debugjob<br />debugjob -g 1  ||GPU||1/4|| 24||1||  188GiB||120 minutes
|-
|debugjob 1<br />debugjob -g 4||GPU|| 1 || 96||4||  755GiB|| 30 minutes
|-
|debugjob 2<br />debugjob -g 8||GPU|| 2 ||192||8||2x755GiB|| 15 minutes
|}
The shell environment in a debugjob will be similar to the environment you get when you have just logged in: only standard modules loaded, no internet access, no write access to the home and project file systems, and no job submissions. By the way, if you want the session to inherit the modules that you had loaded before issuing the debugjob command, you can add "<code>--export=ALL</code>" as the first option to debugjob.

<!--T:175-->
* If your test job requires more time than allowed by <code>debugjob</code>, you can request an interactive session from the regular queue using <code>salloc</code>. For CPU test jobs, the command would be as follows:
<pre>
$ salloc --export=NONE --nodes=N --time=M:00:00 [--ngpus-per-node=G] [--x11]
</pre>
where
* <code>N</code> is the number of nodes  
* <code>M</code> is the number of hours the job should run  
* <code>G</code> is the number of GPUs per node (when applicable). 
* <code>--x11</code> is required for graphical applications (e.g., when using [[ARM_software|ARM DDT]]), but otherwise optional.

<!--T:176-->
'''Note:''' Jobs submitted with <code>salloc</code> may take longer to start than with debugjob and count towards your allocation.

= Submitting jobs to the scheduler = <!--T:177-->

<!--T:178-->
Once you have compiled and tested your code or workflow on the Trillium login nodes and confirmed that it behaves correctly, you are ready to submit jobs to the cluster. These jobs will run on Trillium's compute nodes, and their execution is managed by the scheduler.

<!--T:179-->
Trillium uses SLURM as its job scheduler. More advanced details of how to interact with the scheduler can be found on the [[Running jobs|Slurm page]].  

<!--T:180-->
To submit a job, use the <code>sbatch</code> command on a login node:
<pre>
$ sbatch jobscript.sh
</pre>
CPU compute jobs need to be submitted from the CPU login nodes, while GPU compute nodes must be submitted from the GPU login node.  In both cases, the command is the same, but the options inside the jobscript will have to be different (see below).

<!--T:181-->
The sbatch command places your job into the queue. The job script should contain lines starting with <code>#SBATCH</code> that specify the resources that this script will need (the most common options will be given below). SLURM will begin execution of this script on compute nodes when your job is at the top of the priority queue and these resources are available. 

<!--T:182-->
The priority of a job in the queue depends on requested resources, time spent in the queue, recent past usage, as well as on the SLURM account under which the job was submitted. SLURM accounts correspond to [[Frequently_Asked_Questions_about_the_CCDB#Resource_Allocation_Projects_(RAP)|Resource Allocation Projects]], or RAPs:
* Each PI has at least one RAP, the RAS or default RAP. Users sponsored by that PI have access to the corresponding SLURM account, whose name starts with <code>def-</code>.
* PIs that have a RAC allocation have an additional RAC RAP, to which they can add users.  The names of corresponding SLURM accounts typically start with <code>rrg-</code> or <code>rpp-</code>. Note that RACs are bound to a system, e.g. a RAC for Nibi cannot be used on Trillium.

== Trillium specific restrictions == <!--T:183-->

<!--T:184-->
Because Trillium is designed as a system for large parallel jobs, there are some differences with the General Purpose clusters [[Fir]], [[Nibi]], [[Narval/en|Narval]], and [[Rorqual/en|Rorqual]], which we will now discuss.

=== Job output must be written to the scratch file system === <!--T:185-->

<!--T:186-->
The scratch file system is a fast parallel file system that you should use for writing out data during jobs.  This is enforced by having the home and project directories only available for reading on the compute nodes.

<!--T:187-->
In addition to making sure your application writes to scratch, in most cases, you should also submit your jobs from your <code>$SCRATCH</code> directory (i.e. not <code>$HOME</code> or <code>$PROJECT</code>). The default location for the output files of SLURM are in the directory from which you submit, so if that is not in scratch, the output files would not be written.

=== Default scheduler account === <!--T:188-->

<!--T:189-->
Jobs will run under your group's RAC allocation, or if one is not available, under a RAS allocation.  You can control this explicitly by specifying the account with the <code>--account=ACCOUNT_NAME</code> option in your job script or submission command. For users with multiple allocations, specifying the account name is highly recommended.

=== No job submission from jobs === <!--T:190-->

<!--T:191-->
Jobs cannot be submitted from compute nodes (nor datamover nodes). This prevents accidentally spawning many jobs, overloading the scheduler, and overloading the backup process.

=== Whole node or whole gpu scheduling === <!--T:192-->

<!--T:193-->
It is not possible to request a certain number of core on Trillium.  On the CPU subcluster, all jobs must use full nodes. That means the minimum size of a CPU job has 192 cores are its disposal which you must use effectively. If you are running serial or low-core-count jobs you must still use all 192 cores on the node by bundling multiple independent tasks in one job script. For examples, see [[GNU Parallel]] and [[META-Farm: Advanced features and troubleshooting#WHOLE_NODE_mode|this section of the META-Farm advanced page]].

<!--T:194-->
If your job underutilizes the cores, our support team may reach out to assist you in optimizing your workflow, or you can [mailto:trillium@tech.alliancecan.ca contact us] to get assistance.

<!--T:195-->
On the GPU subcluster, each node contains 4 GPUs. The scheduler allows you to request either a whole number of nodes, or a single GPU. The latter amounts to a quarter node, with 24 cores and about 188GiB of RAM.  It is important to use the GPU efficiently.  Trillium does not support MIG as on the other clusters (MIG allows you to schedule a fraction of a GPU), but you can use [[Hyper-Q / MPS]] within your jobs.

=== Memory requests are ignored === <!--T:196-->

<!--T:197-->
Memory requests are ignored. Your CPU jobs always receive <code>N × 768GB </code> of RAM, where <code>N</code> is the number of nodes and 768GB is the amount of memory on each node. Your GPU full-node jobs get the same amount of memory, while single-GPU jobs get 1/4 of the memory, i.e., 188GiB.

== Common options for job script == <!--T:198-->

<!--T:199-->
The following options are commonly used:

<!--T:200-->
{| class="wikitable"
!option
!short option
!meaning
!notes
|-
|<code>--nodes</code>||<code>-N</code>||number of nodes||Recommended to always include this
|-
|<code>--ntasks-per-node</code>|| ||number of tasks for srun/mpirun to launch per node||Prefer this over <code>--ntasks</code>
|-
|<code>--ntasks</code>||<code>-n</code>||number of tasks for srun/mpirun to launch||
|-
|<code>--cpus-per-task</code>||<code>-c</code>||number of cores per task; ||Typically for (OpenMP) threads
|-
|<code>--time</code>||<code>-t</code>||duration of the job||
|-
|<code>--job-name</code>||<code>-J</code>||specify a name for the job||
|-
|<code>--output</code>||<code>-o</code>||file to redirect standard ouput to||Can be a pattern using e.g. %j for the jobid.
|-
|<code>--mail-type|| ||when to send email (e.g. BEGIN, END, FAIL, ALL)
|-
|<code>--gpus-per-node|| || number of gpus to use on each node || Either 1 or 4 is allowed on the GPU subcluster
|-
|<code>--partition</code>||<code>-p</code>||partition to submit to||See below for available partitions
|-
|<code>--account</code>||<code>-A</code>||slurm account to use||For many users, this is automatic on Trillium
|-
|<code>--mem<code>|| || amount of memory requested||Ignored on Trillium, you get all the memory
|}

<!--T:201-->
These options should be put in separate comment lines at the top of the job script (but after <code>#!/bin/bash</code>), prefixed with <code>#SBATCH</code>. They can also be used as command line options for <code>salloc</code>. Some examples of job scripts are given below.

<!--T:202-->
More options and details can be found on the [[Running jobs]] page and in the [https://slurm.schedmd.com/sbatch.html SLURM documentation].

== Submitting jobs on the CPU subcluster == <!--T:203-->

=== Partitions and limits === <!--T:204-->

<!--T:205-->
There are limits to the size and duration of your jobs, the number of jobs you can run, and the number of jobs you can have queued. It matters whether a user is part of a group with a RAC allocation (e.g. an RRG or RPP) or not. It also matters in which "partition" the job runs. "Partitions" are SLURM-speak for use cases. You specify the partition with the <code>-p</code> parameter to <code>sbatch</code> or <code>salloc</code>, but if you do not specify one, your job will run in the <code>compute</code> partition, which is the most common case.

<!--T:206-->
{| class="wikitable"
!Usage
!Partition
!Limit on Running jobs
!Limit on Submitted jobs (incl. running)
!Min. size of jobs
!Max. size of jobs
!Min. walltime
!Max. walltime 
|-
|Compute jobs ||compute || 150 || 500 || 1 node (192&nbsp;cores) || default:&nbsp;10&nbsp;nodes&nbsp;(1920&nbsp;cores) <br> with&nbsp;allocation:&nbsp;128&nbsp;nodes&nbsp;(24576&nbsp;cores)<sup>*</sup>|| 15 minutes || 24 hours
|-
|Testing or troubleshooting || debug || 1 || 1 || 1 node (192&nbsp;cores) || 2 nodes (384 cores)|| N/A || 1 hour
|}
<small><sup>*</sup> This is a safe-guard, if your rrg involves running larger jobs, let us know.</small>

<!--T:207-->
Even if you respect these limits, your jobs will still have to wait in the queue. The waiting time depends on many factors such as your group's allocation amount, how much allocation has been used in the recent past, the number of requested nodes and walltime, and how many other jobs are waiting in the queue.

=== Example: MPI job === <!--T:208-->

<!--T:209-->
<source lang="bash">
#!/bin/bash
#SBATCH --nodes=2
#SBATCH --ntasks-per-node=192
#SBATCH --time=01:00:00
#SBATCH --job-name=mpi_job
#SBATCH --output=mpi_output_%j.txt
#SBATCH --mail-type=FAIL

<!--T:210-->
cd $SLURM_SUBMIT_DIR

<!--T:211-->
module load StdEnv/2023
module load gcc/12.3
module load openmpi/4.1.5

<!--T:212-->
source /scinet/vast/etc/vastpreload-openmpi.bash # important if doing MPI-IO

<!--T:213-->
mpirun ./mpi_example
</source>

<!--T:214-->
Submit this script from a CPU login node while in your <code>$SCRATCH</code> directory with the command:
<pre>
$ sbatch mpi_job.sh
</pre>

<!--T:215-->
<ul>
<li>First line indicates that this is a bash script.</li>
<li>Lines starting with <code>#SBATCH</code> go to SLURM.</li>
<li><code>sbatch</code> reads these lines as a job request (which it gives the name <code>mpi_job</code>).</li>
<li>In this case, SLURM looks for 2 nodes each running 192 tasks, for 1 hour.</li>
<li>Once it finds such nodes, it runs the script, which does the following:
<ul>
<li>Change to the submission directory;</li>
<li>Loads modules;</li>
<li>Preloads a library tuning MPI-IO for the VAST file system; change this to source /scinet/vast/etc/vastpreload-intelmpi.bash if using IntelMPI instead of OpenMPI. '''Note: <code>mpirun</code> must be used for the VAST preload library to take effect, it does not work with  <code>srun</code>.'''</li> 
<li>Runs the <code>mpi_example</code> application (SLURM will inform <code>mpirun</code> or <code>srun</code> how many processes to run).</li>
</ul>
</li>
</ul>

=== Example: OpenMP job === <!--T:216-->

<!--T:217-->
<source lang="bash">
#!/bin/bash
#SBATCH --nodes=1
#SBATCH --ntasks=1
#SBATCH --cpus-per-task=192
#SBATCH --time=01:00:00
#SBATCH --job-name=openmp_job
#SBATCH --output=openmp_output_%j.txt
#SBATCH --mail-type=FAIL

<!--T:218-->
cd $SLURM_SUBMIT_DIR

<!--T:219-->
module load StdEnv/2023
module load gcc/12.3

<!--T:220-->
export OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK

<!--T:221-->
./openmp_example
# or "srun ./openmp_example"
</source>

<!--T:222-->
Submit this script from a CPU login node while in your <code>$SCRATCH</code> directory with the command:
<pre>
$ sbatch openmp_job.sh
</pre>

<!--T:223-->
<ul>
<li>First line indicates that this is a Bash script.</li>
<li>Lines starting with <code>#SBATCH</code> are directives for SLURM.</li>
<li><code>sbatch</code> reads these lines as a job request (which it gives the name <code>openmp_job</code>).</li>
<li>In this case, SLURM looks for one node with 192 CPUs for a single task running up to 192 OpenMP threads, for 1 hour.</li>
<li>Once such a node is allocated, it runs the script:
  <ul>
    <li>Changes to the submission directory;</li>
    <li>Loads the required modules;</li>
    <li>Sets <code>OMP_NUM_THREADS</code> based on SLURM’s CPU allocation;</li>
    <li>Runs the <code>openmp_example</code> application.</li>
  </ul>
</li>
</ul>

=== Example: hybrid MPI/OpenMP job === <!--T:224-->

<!--T:225-->
<source lang="bash">
#!/bin/bash
#SBATCH --nodes=2
#SBATCH --ntasks-per-node=48
#SBATCH --cpus-per-task=4
#SBATCH --time=01:00:00
#SBATCH --job-name=hybrid_job
#SBATCH --output=hybrid_output_%j.txt
#SBATCH --mail-type=FAIL

<!--T:226-->
cd $SLURM_SUBMIT_DIR

<!--T:227-->
module load StdEnv/2023
module load gcc/12.3
module load openmpi/4.1.5

<!--T:228-->
export OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK
export OMP_PLACES=cores
export OMP_PROC_BIND=true

<!--T:229-->
export CORES_PER_L3CACHE=8
export RANKS_PER_L3CACHE=$(( $CORES_PER_L3CACHE / $OMP_NUM_THREADS ))  # this works up to 8 threads 

<!--T:230-->
source /scinet/vast/etc/vastpreload-openmpi.bash # important if doing MPI-IO

<!--T:231-->
mpirun --bind-to core --map-by ppr:$RANKS_PER_L3CACHE:l3cache:pe=$OMP_NUM_THREADS ./hybrid_example

<!--T:232-->
</source>

<!--T:233-->
Submit this script from a CPU login node while in your <code>$SCRATCH</code> directory with the command:
<pre>
$ sbatch hybrid_job.sh
</pre>

<!--T:234-->
<ul>
<li>First line indicates that this is a bash script.</li>
<li>Lines starting with <code>#SBATCH</code> go to SLURM.</li>
<li><code>sbatch</code> reads these lines as a job request (which it gives the name <code>hybrid_job</code>).</li>
<li>In this case, SLURM looks for 2 nodes each running 48 tasks, each with 4 threads for 1 hour.</li>
<li>Once it finds such a node, it runs the script:
<ul>
<li>Change to the submission directory;</li>
<li>Loads modules;</li>
<li>Preloads a library tuning MPI-IO for the VAST file system; change this to source /scinet/vast/etc/vastpreload-intelmpi.bash if using IntelMPI instead of OpenMPI. '''Note: <code>mpirun</code> must be used for the VAST preload library to take effect, it does not work with <code>srun</code>.'''</li>
<li>Runs the <code>hybrid_example</code> application. While SLURM will inform <code>mpirun</code> how many processes to run, it needs help to spread the processes and threads evenly over the cores.  The --map-by option solves this. <br>
(for more than 8 and at most 24 threads per process, change 'l3cache' to 'numa' and for more than 24, change it to 'socket').
</li>

<!--T:235-->
</ul>
</li>
</ul>

== Submitting jobs for the GPU subcluster == <!--T:236-->

=== Partitions and limits === <!--T:237-->

<!--T:238-->
As with the CPU subcluster, there are limits to the size and duration of your jobs, the number of jobs you can run, and the number of jobs you can have queued, and whether a user is part of a group with a RAC allocation or not. There are more partitions for this subcluster than for the CPU subcluster to support scheduling by GPU instead of by node (each node has 4 GPUs). 

<!--T:239-->
On Trillium, you are only allowed to request exactly 1 GPU or a multiple of 4 GPUs. You cannot request --gpus-per-node=2 or 3, nor can you use NVIDIA's MIG technology to allocate a subdivision of a GPU.  Inside a job, you can use NVIDIA's Multi-Process Service (MPS) to share a GPU among processes running on the same job.

<!--T:240-->
* For single-GPU jobs, use <code>--gpus-per-node=1</code>.
* For whole-node GPU job, use <code>--gpus-per-node=4</code>.

<!--T:241-->
{| class="wikitable"
!Usage
!Partition
!Limit on Running jobs
!Limit on Submitted jobs (incl. running)
!Min. size of jobs
!Max. size of jobs
!Min. walltime
!Max. walltime 
|-
|GPU compute jobs ||compute || 150 || 500 || 1/4 node (24&nbsp;cores / 1GPU) || default:&nbsp;5&nbsp;nodes&nbsp;(480&nbsp;cores/20 GPUs) <br> with&nbsp;allocation:&nbsp;25&nbsp;nodes&nbsp;(2400&nbsp;cores/100 GPUs)|| 15 minutes || 24 hours
|-
|Testing GPU jobs || debug || 1 || 1 || 1/4 node (24 cores / 1 GPU) || 2 nodes (192 cores/ 8 GPUs)|| N/A || 2 hours (1 GPU) - 30 minutes (8 GPUs)
|}

<!--T:242-->
Even if you respect these limits, your jobs will still have to wait in the queue. The waiting time depends on many factors such as your group's allocation amount, how much allocation has been used in the recent past, the number of requested nodes and walltime, and how many other jobs are waiting in the queue.

=== Example: Single-GPU Job === <!--T:243-->

<!--T:244-->
<source lang="bash">
#!/bin/bash
#SBATCH --job-name=single_gpu_job         # Job name
#SBATCH --output=single_gpu_job_%j.out    # Output file (%j = job ID)
#SBATCH --nodes=1                         # Request 1 node
#SBATCH --gpus-per-node=1                 # Request 1 GPU
#SBATCH --time=00:30:00                   # Max runtime (30 minutes)

<!--T:245-->
# Load modules
module load StdEnv/2023
module load cuda/12.6
module load python/3.11.5

<!--T:246-->
# Activate Python environment (if applicable)
source ~/myenv/bin/activate

<!--T:247-->
# Check GPU allocation
srun nvidia-smi

<!--T:248-->
# Run your workload
srun python my_script.py
</source>

=== Example: Whole-Node (4 GPUs) Job === <!--T:249-->

<!--T:250-->
<source lang="bash">
#!/bin/bash
#SBATCH --job-name=whole_node_gpu_job
#SBATCH --output=whole_node_gpu_job_%j.out
#SBATCH --nodes=1
#SBATCH --gpus-per-node=4
#SBATCH --time=02:00:00

<!--T:251-->
module load StdEnv/2023
module load cuda/12.6
module load python/3.11.5

<!--T:252-->
# Activate Python environment (if applicable)
source ~/myenv/bin/activate

<!--T:253-->
srun python my_distributed_script.py
</source>

=== Example: Multi-Node GPU Job === <!--T:254-->

<!--T:255-->
<source lang="bash">
#!/bin/bash
#SBATCH --job-name=multi_node_gpu_job
#SBATCH --output=multi_node_gpu_job_%j.out
#SBATCH --nodes=2                        # Request 2 full nodes
#SBATCH --gpus-per-node=4                # 4 GPUs per node (full node)
#SBATCH --time=04:00:00

<!--T:256-->
module load StdEnv/2023
module load cuda/12.6
module load openmpi/4.1.5

<!--T:257-->
# Check all GPUs allocated
srun nvidia-smi

<!--T:258-->
# Activate Python environment (if applicable)
source ~/myenv/bin/activate

<!--T:259-->
# Example: run a distributed training job with 8 GPUs (2 nodes × 4 GPUs)
srun python train_distributed.py
</source>

=== Best Practices for GPU Jobs === <!--T:260-->

<!--T:261-->
* Do not use <code>--mem</code> — memory is fixed per GPU (192 GB) or per node (768 GB).
* Always specify node count, and <code>--gpus-per-node=4</code> for whole-node or multi-node jobs.
* Load only the modules you need — see [[Using modules]].
* Be explicit with software versions for reproducibility (e.g., <code>cuda/12.6</code> rather than just <code>cuda</code>).
* Test on a single GPU before scaling to multiple GPUs or nodes.
* Monitor usage with <code>nvidia-smi</code> to ensure GPUs are fully utilized.

= Monitoring = <!--T:262-->

== Monitoring the queue == <!--T:263-->

<!--T:264-->
Once your job is submitted to the queue, you can monitor its status and performance using the following SLURM commands:

<!--T:265-->
<ul>
<li><p><code>squeue</code> shows all jobs in the queue. Use <code>squeue -u $USER</code> to view only your jobs.</p></li>
<!-- <li><p><code>sqc</code> is a SciNet-specific, faster version of <code>squeue</code> that shows a cached snapshot of the queue.</p></li> -->
<li><p><code>squeue -j JOBID</code> shows the current status of a specific job. Alternatively, use <code>scontrol show job JOBID</code> for detailed information, including allocated nodes, resources, and job flags.</p>
</li>

<!--T:266-->
<li><p><code>squeue --start -j JOBID</code> gives a rough estimate of when a pending job is expected to start. Note that this estimate is often inaccurate and can change depending on system load and priorities.</p></li>

<!--T:267-->
<li><p><code>scancel JOBID</code> cancels a job you submitted.</p></li>

<!--T:268-->
<li><p><code>jobperf JOBID</code> gives a live snapshot of the CPU and memory usage of your job while it is running.</p></li>

<!--T:269-->
<li><p><code>sacct</code> shows information about your past jobs, including start time, run time, node usage, and exit status.</p></li>
</ul>

<!--T:270-->
More details on monitoring jobs can be found on the [[Running jobs | Slurm page]].

== Monitoring running and past jobs == <!--T:271-->

<!--T:272-->
Note that after your job has finished, it will be removed from the queue, so SLURM commands that query the queue like squeue and sacct will not find your job anymore.

<!--T:273-->
Your past jobs and their resource usage can be inspected through the [https://my.scinet.utoronto.ca my.SciNet] portal.  This portal saves information about all jobs, including performance data collected every two minutes while the job was running. 

= Quick Reference for Common Commands = <!--T:274-->

<!--T:276-->
{| class="wikitable"
! Command !! Description
|-
| sbatch <script> || Submit a batch job script
|-
| squeue [-u $USER] || View queued jobs (optionally for current user)
|-
| scancel <JOBID> || Cancel a job
|-
| sacct || View accounting data for recent past jobs
|-
| module load <module> || Load a software module
|-
| module list || List loaded modules
|-
| module avail || List available modules
|-
| module spider <module> || Search for modules and dependencies
|-
| debugjob [N] || Request a short debug job (on N nodes)
|-
| diskusage_report || Check storage quotas
|-
| jobperf <JOBID> || Monitor CPU and memory usage of a running job
|-
| nvidia-smi || Check GPU status (on GPU nodes)
|}
</translate>